#!/bin/sh
# The madtclsh path is longer than 32 characters. So, we take advantage
# of the fact that a backslash continues a comment line in tcl \
exec MADROOT/bin/madtclsh "$0" ${1+"$@"}


# UpdateImfparms reads a imf file and adds
# the indices to the new-style Madrigal IMF parameter file. The
# new style Madrigal IMF parameter file has 24 records per day,
# so that each 1-hour period has its own record, in accord with the
# Cedar standard.  The old style had one record per day, with 24 2D records
# with different times, in conflict with the prolog times.  The new
# style IMF file is generally called imf631127g.002, and the old
# style imf631127g.001, although this is not enforced.  If a IMF value is
# already in the IMF parameter file, it is replaced.
#
# Updated 4/23/2004 to create an entirely new imf631127g.002 type file if
# desired. Fixed swq 4 digit bug.
#
# The IMF data are located at :
#     ftp://nssdcftp.gsfc.nasa.gov/spacecraft_data/omni/
#
# Usage: updateImfparms \[options\]
#   Options:
#     -i imfFileIn     Original IMF parameter file (use None for no input)
#     -o imfFileOut    Updated IMF parameter file
#     -d imfFile       New IMF file to add to original
#     -h               Help information
#   If the -o option is omitted, imfFileOut = ./imfFileOut
#   If  -d is omitted, a summary of imffileIn is displayed.
#   If -d is present, imffileOut will be
#     updated with the IMF parameters in imfFile.
#
# e.g.: updateImfparms -i /opt/madrigal/experiments/1957/imf/01jan50/imf631127g.002 -d omni2002.data
#

proc printUsage {} {

    puts "Usage: updateImfparms \[options\]"
    puts "  Options:"
    puts "    -i imfFileIn     Original IMF parameter file (use None for no input)"
    puts "    -o imfFileOut    Updated IMF parameter file"
    puts "    -d imfFile       New IMF file to add to original"
    puts "    -h               Help information"
    puts "  If the -o option is omitted, imfFileOut = ./imfFileOut"
    puts "  If  -d is omitted, a summary of imffileIn is displayed."
    puts "  If -d is present, imffileOut will be updated with the IMF parameters in imfFile."

    return 0 
}

set debug 0


# Get number of arguments
set nargs $argc
if {$nargs == 0 || $nargs > 9} {
    printUsage
    exit
}

# Process arguments
set isimffilein 0
set isimffileout 0
set isnewfile 0
set i 0
while {$i < $nargs} {
    set option [lindex $argv $i]

    if {$option == "-i"} {
        incr i
        if {$i == $nargs} {
            puts "Error: Option $option requires file name argument"
            printUsage
            return -1
        }
        set imfFileIn [lindex $argv $i]
        incr i
        set isimffilein 1

    } elseif {$option == "-o"} {
        incr i
        if {$i == $nargs} {
            puts "Option $option requires file name argument"
            printUsage
            return -1
        }
        set imfFileOut [lindex $argv $i]
        incr i
        set isimffileout 1

    } elseif {$option == "-d"} {
        incr i
        if {$i == $nargs} {
            puts "Option $option requires file name argument"
            printUsage
            return -1
        }
        set newFile [lindex $argv $i]
        incr i
        set isnewfile 1

    } elseif {$option == "-h"} {
        incr i
        printUsage
        return 0

    } else {
        puts "Error: Unknown option $option"
        printUsage
        return -1
    }
}

if {$isimffilein == 0} {
    printUsage
    return -1
}

puts ""
puts "Input IMF parameter file = $imfFileIn"

if {$isimffileout == 0} {
    puts ""
    puts "Output IMF parameter file = ./imfFileOut"
    set imfFileOut "./imfFileOut"
} else {
    puts ""
    puts "Output IMF parameter file = $imfFileOut"
}

if {$isnewfile == 1} {
    puts ""
    puts "Input new IMF file to add = $newFile"
} else {
    puts ""
    puts "No new IMF file"
}


# Get parameter codes
cedarCode cedarCode



# Process new IMF parameter file
if {[catch {
    if {$isnewfile == 1} {
        set imfkeys {}
        set imfjdaynos {}
        set bxgsml {}
        set bygsml {}
        set bzgsml {}
        set bygsel {}
        set bzgsel {}
        set swdenl {}
        set swspdl {}
        set swql   {}
        set fpg [open $newFile]
        set j 0
        while {[gets $fpg line] >= 2} {
            set year [string range $line 0 4]
            set dayno [string range $line 5 8]
            set hour [string range $line 9 11]
                        
            # use jday and jdater to convert from year and dayno to day, month, year
            set firstDay [jday 1 1 $year]
            set thisDay [expr $firstDay+$dayno-1]
            set thisDate [jdater $thisDay]
            set day [lindex $thisDate 0]
            set month [lindex $thisDate 1]
            
            set imfkeys [lappend imfkeys [getKey $year $month $day $hour 0 0]]
            set imfjdaynos [lappend imfjdaynos [jday $day $month $year]]
            
            # read data, checking for missing data, and converting to Cedar units
            set bxgsm [string trim [string range $line 55 60]]
            if {$bxgsm == 999.9} {
                set bxgsm -32767
            } else {
                set bxgsm [expr int([expr $bxgsm*100])]
            }
            set bxgsml [lappend bxgsml $bxgsm]
            
            set bygsm [string trim [string range $line 73 78]]
            if {$bygsm == 999.9} {
                set bygsm -32767
            } else {
                set bygsm [expr int([expr $bygsm*100])]
            }
            set bygsml [lappend bygsml $bygsm]
            
            set bzgsm [string trim [string range $line 79 84]]
            if {$bzgsm == 999.9} {
                set bzgsm -32767
            } else {
                set bzgsm [expr int([expr $bzgsm*100])]
            }
            set bzgsml [lappend bzgsml $bzgsm]
            
            set bygse [string trim [string range $line 61 66]]
            if {$bygse == 999.9} {
                set bygse -32767
            } else {
                set bygse [expr int([expr $bygse*100])]
            }
            set bygsel [lappend bygsel $bygse]
            
            set bzgse [string trim [string range $line 67 72]]
            if {$bzgse == 999.9} {
                set bzgse -32767
            } else {
                set bzgse [expr int([expr $bzgse*100])]
            }
            set bzgsel [lappend bzgsel $bzgse]
            
            set swden [string trim [string range $line 124 129]]
            if {$swden == 999.9} {
                set swden -32767
            } else {
                set swden [expr int([expr $swden*10])]
            }
            set swdenl [lappend swdenl $swden]
            
            set swspd [string trim [string range $line 130 135]]
            if {$swspd == 9999.} {
                set swspd -32767
            } else {
                set swspd [expr int([expr $swspd*10])]
            }
            set swspdl [lappend swspdl $swspd]
            
            set swq_imf   [string trim [string range $line 17 19]]
            if {$swq_imf == 0 || $swq_imf == 99} {
                set swq -32767
            } else {
	        set swq [expr $swq_imf * 100]
	    }
	    
	    set swq_sw   [string trim [string range $line 20 22]]
            if {$swq == -32767 || $swq_sw == 0 || $swq_sw == 99} {
                set swq -32767
            } else {
	        set swq [expr $swq + $swq_sw]
	    } 
	    
            set swql [lappend swql $swq]
            
            if {$j == 0} {
                set firstDateNEW [format "%2.2d/%2.2d/%4d" $month $day $year]
            }
            incr j
        }
        
        set lastDateNEW [format "%2.2d/%2.2d/%4d" $month $day $year]
        set firstJdaynoNEW [lindex $imfjdaynos 0]
        set lastJdaynoNEW [lindex $imfjdaynos [expr [llength $imfjdaynos]-1]]

        puts ""
        puts "New IMF parameter file:"
        puts "  First Day: $firstJdaynoNEW  $firstDateNEW"
        puts "   Last Day: $lastJdaynoNEW  $lastDateNEW"
        if {$debug} {
            puts "[llength $imfkeys] IMF parameter keys"
            puts $imfkeys
            puts "[llength $imfjdaynos] IMF Julian day numbers"
            puts $imfjdaynos
        }
    }

} result]} {
    puts "Error processing new IMF parameter file"
    puts $result
    exit
}

# Create madrec object for the input IMF parameter file
set status [catch {mad madin}]
if {$status != 0} {
    puts "mad Error: [$madin get error]"
    exit
}

# get old data unless imfFileIn == None
if {[string compare $imfFileIn "None"] != 0} {
    set status [catch {$madin open 1 $imfFileIn}]
    if {$status != 0} {
        puts "mad open Error: [$madin get error]"
        exit
    }
}

# Create madrec object for the output IMF parameter file
set status [catch {mad madout}]
if {$status != 0} {
    puts "mad Error: [$madout get error]"
    exit
}
set status [catch {$madout open 20 $imfFileOut}]
if {$status != 0} {
    puts "mad open Error: [$madout get error]"
    exit
}

# Create madrec object for the memory image of IMF parameter file
set status [catch {mad madmem}]
if {$status != 0} {
    puts "mad Error: [$madmem get error]"
    exit
}
# get old data unless imfFileIn == None
if {[string compare $imfFileIn "None"] != 0} {
    set status [catch {$madmem open 30 $imfFileIn}]
    if {$status != 0} {
        puts "mad open Error: [$madmem get error]"
        exit
    }
}

# Print a one line per record summary of the file
#puts ""
#puts "IMF parameter file:"
#puts "                 rec jday1       Start Time            End Time       kinst krec kindat"
set rec 0
set jdayl 0
# get old data unless imfFileIn == None
if {[string compare $imfFileIn "None"] != 0} {
    while {[set status [$madin getNextRecord]] == 0} {

	incr rec


	set recno [format %5d $rec]
	set startTime [$madin get startTime]
	set yr1 [lindex $startTime 0]
	set mo1 [lindex $startTime 1]
	set dy1 [lindex $startTime 2]
	set hr1 [lindex $startTime 3]
	set mn1 [lindex $startTime 4]
	set sc1 [lindex $startTime 5]
	set zero 0
	if {[string length $hr1] == 1} {
            set hr1 $zero$hr1
	}
	if {[string length $mn1] == 1} {
            set mn1 $zero$mn1
	}
	if {[string length $sc1] == 1} {
            set sc1 $zero$sc1
	}
	set endTime [$madin get endTime]
	set yr2 [lindex $endTime 0]
	set mo2 [lindex $endTime 1]
	set dy2 [lindex $endTime 2]
	set hr2 [lindex $endTime 3]
	set mn2 [lindex $endTime 4]
	set sc2 [lindex $endTime 5]
	set zero 0
	if {[string length $hr2] == 1} {
            set hr2 $zero$hr2
	}
	if {[string length $mn2] == 1} {
            set mn2 $zero$mn2
	}
	if {[string length $sc2] == 1} {
            set sc2 $zero$sc2
	}
	set startDate [format %2.2d/%2.2d/%2.2d $mo1 $dy1 $yr1]
	set endDate [format %2.2d/%2.2d/%2.2d $mo2 $dy2 $yr2]
	set jday1 [expr int([$madin get startJday])]
	set jday2 [expr int([$madin get endJday])]
	set summary "$recno $jday1 \
        	 $startDate $hr1:$mn1:$sc1  $endDate $hr2:$mn2:$sc2 \
        	 [$madin get kinst] \
        	 [$madin get krec] \
        	 [$madin get kindat]"
	set summary "$recno $jday1 \
        	 $startDate $hr1:$mn1:$sc1  $endDate $hr2:$mn2:$sc2 \
        	 [$madin get kinst] \
        	 [$madin get 1dInt 2204] \
        	 [$madin get 1dInt 2206] \             
        	 [$madin get 1dInt 2208] \             
        	 [$madin get 1dInt 2216] \            
        	 [$madin get 1dInt 2219] \             
        	 [$madin get 1dInt 2232] \
        	 [$madin get 1dInt 2234] \             
        	 [$madin get 1dInt 2236]"         

    #puts $summary
	if {$jday1 != $jday2} {
            puts "Error in:     $summary"
            puts "    Start and end Julian Day numbers, $jday1 and $jday2 are not the same."
	}
	set jdayl $jday1
	if {$rec == 1} {
            set firstJdaynoOLD $jday1
            set firstDateOLD [format %2.2d/%2.2d/%2.2d $mo1 $dy1 $yr1]
            #puts "First record: $summary"
	}
    }
    #puts "Exit status = $status"
    #puts "Last record:  $summary"

    set lastJdaynoOLD $jday1
    set lastDateOLD [format %2.2d/%2.2d/%2.2d $mo1 $dy1 $yr1]

    puts ""
    puts "Original IMF parameter file:"
    puts "  First Day: $firstJdaynoOLD  $firstDateOLD"
    puts "   Last Day: $lastJdaynoOLD  $lastDateOLD"
    
} else {
    # 1/1/1963
    set lastJdaynoOLD 2438030

}

if {$isnewfile==0} {
    puts "No new IMF parameter file - Exiting"
    exit
}


# describe new records to be added, if any
puts ""
if {$lastJdaynoNEW > $lastJdaynoOLD} {
    set firstJdaynoAdd [expr $lastJdaynoOLD+1]
    set lastJdaynoAdd $lastJdaynoNEW
    set d [jdater $firstJdaynoAdd]
    set firstDateAdd [format %2.2d/%2.2d/%2.2d [lindex $d 1] [lindex $d 0] [lindex $d 2]]
    set d [jdater $lastJdaynoAdd]
    set lastDateAdd [format %2.2d/%2.2d/%2.2d [lindex $d 1] [lindex $d 0] [lindex $d 2]]
    puts "Adding new records from $firstDateAdd (jday=$firstJdaynoAdd) to $lastDateAdd (jday=$lastJdaynoAdd)"
    puts "  to original IMF parameter file."
} else {
    puts "No new records to be added"
}

# describe whether any IMF records will be modified in existing file
puts ""
if {$firstJdaynoNEW < $lastJdaynoOLD} {
    set d [jdater $firstJdaynoNEW]
    set firstDateAdd [format %2.2d/%2.2d/%2.2d [lindex $d 1] [lindex $d 0] [lindex $d 2]]
    if {$lastJdaynoNEW < $lastJdaynoOLD} {
        set lastJdaynoUpNEW $lastJdaynoNEW
    } else {
        set lastJdaynoUpNEW $lastJdaynoOLD
    }
    set d [jdater $lastJdaynoUpNEW]
    set lastDateAdd [format %2.2d/%2.2d/%2.2d [lindex $d 1] [lindex $d 0] [lindex $d 2]]
    puts "Modifying IMF data from $firstDateAdd (jday=$firstJdaynoNEW) to $lastDateAdd (jday=$lastJdaynoUpNEW)"
    puts "  in existing IMF parameter file."
} 




# Add records to the memory image as necessary
set lprol 16
set jpar 8
set mpar 0
set nrow 0
set krec 1002
set kinst 120
set kindat 30012
set ibyr 2001
set ibmo 8
set ibdy 31
set ibh 0
set ibm 0
set ibs 0
set ibcs 0
set ieyr 2001
set iemo 8
set iedy 31
set ieh 23
set iem 59
set ies 59
set iecs 99
# insert new records only if needed
set i 0
if {$lastJdaynoNEW > $lastJdaynoOLD} {
    for {set jday $firstJdaynoAdd} {$jday <= $lastJdaynoAdd} {incr jday} {
        # now loop through 24 1 hour periods
        for {set loopHour 0} {$loopHour < 24} {incr loopHour } {
            set d [jdater $jday]
            set ibyr [lindex $d 2]
            set ibmo [lindex $d 1]
            set ibdy [lindex $d 0]
            set ibh $loopHour
            set ieyr $ibyr
            set iemo $ibmo
            set iedy $ibdy
            set ieh $loopHour
	    
	    if {[string compare $imfFileIn "None"] != 0} {

        	set status [catch {$madmem createRecord $lprol $jpar $mpar $nrow $krec \
			        	 $kinst $kindat \
			        	 $ibyr $ibmo $ibdy $ibh $ibm $ibs $ibcs \
			        	 $ieyr $iemo $iedy $ieh $iem $ies $iecs} result]
        	if {$status != 0} {
                    puts "createRecord Error: $result"
                    exit
        	}
        	# Initialize all data values to "Missing"
        	$madmem set 1dInt 2204 -32767 0
        	$madmem set 1dInt 2206 -32767 1
        	$madmem set 1dInt 2208 -32767 2
        	$madmem set 1dInt 2216 -32767 3
        	$madmem set 1dInt 2218 -32767 4
        	$madmem set 1dInt 2232 -32767 5
        	$madmem set 1dInt 2234 -32767 6
        	$madmem set 1dInt 2236 -32767 7



        	$madmem putNextRecord
	    } else {
	    
	        set status [catch {$madout createRecord $lprol $jpar $mpar $nrow $krec \
			        	 $kinst $kindat \
			        	 $ibyr $ibmo $ibdy $ibh $ibm $ibs $ibcs \
			        	 $ieyr $iemo $iedy $ieh $iem $ies $iecs} result]
        	if {$status != 0} {
                    puts "createRecord Error: $result"
                    exit
        	}
        	# Initialize all data values to "Missing"
        	$madout set 1dInt 2204 [lindex $bxgsml $i]  0
                $madout set 1dInt 2206 [lindex $bygsml $i]  1
                $madout set 1dInt 2208 [lindex $bzgsml $i]  2
                $madout set 1dInt 2216 [lindex $bygsel $i]  3
                $madout set 1dInt 2218 [lindex $bzgsel $i]  4
                $madout set 1dInt 2232 [lindex $swdenl $i]  5
                $madout set 1dInt 2234 [lindex $swspdl $i]  6
                $madout set 1dInt 2236 [lindex $swql $i]    7

        	$madout putNextRecord
		
		incr i
	    }
	    
        }
    }
} 


if {[string compare $imfFileIn "None"] != 0} {
    if {[llength $imfkeys] > 0} {
	puts ""
	puts "Enter new IMF parameter values into output file"
    }
    set i 0
    foreach key $imfkeys {
	set status [catch {$madmem getRecordByKey $key } result]
	if {$status == 0} {
            $madmem set 1dInt 2204 [lindex $bxgsml $i]  0
            $madmem set 1dInt 2206 [lindex $bygsml $i]  1
            $madmem set 1dInt 2208 [lindex $bzgsml $i]  2
            $madmem set 1dInt 2216 [lindex $bygsel $i]  3
            $madmem set 1dInt 2218 [lindex $bzgsel $i]  4
            $madmem set 1dInt 2232 [lindex $swdenl $i]  5
            $madmem set 1dInt 2234 [lindex $swspdl $i]  6
            $madmem set 1dInt 2236 [lindex $swql $i]    7
	} else {
            puts "$status $result *"
	}
	incr i
    }
}


if {[string compare $imfFileIn "None"] != 0} {
    # Copy the memory image to the output file
    puts ""
    puts "Write the output IMF parameter file"
    $madmem rewind
    while {[set status [$madmem getNextRecord]] == 0} {
	$madmem copy $madout
	$madout putNextRecord
    }
}

# Close file and delete madrec object
puts ""
puts "Close all files and exit"
if {[string compare $imfFileIn "None"] != 0} {
    $madin close
    $madin destroy
}
$madout close
$madout destroy
#$madmem destroy


exit

