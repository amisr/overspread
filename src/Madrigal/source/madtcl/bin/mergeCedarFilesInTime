#!/bin/sh
# The madtclsh path is longer than 32 characters. So, we take advantage
# of the fact that a backslash continues a comment line in tcl \
exec MADROOT/bin/madtclsh "$0" ${1+"$@"}

# $Id: mergeCedarFilesInTime,v 1.3 2008/05/13 19:04:06 brideout Exp $

# mergeCedarFilesInTime merges specified records of two CEDAR files into
# a single file.  Unlike mergeCedarFiles, the merged records are combined 
# in time order, and not file by file. The input file may be any of the 5 supported CEDAR
# formats (Madrigal, Blocked Binary, Cbf, Unblocked Binary or ASCII"),
# and may include any mixture of prologue, header and data records. The
# format of the input files are determined automatically. 
# Usage: mergeCedarFilesInTime [options]
#   Options:
#       -i file rec1 rec2    Add records rec1 to rec2 of file to outFile
#       -o outFile
#       -t fileType          set type of outFile to fileType
#           filetype = 1  Madrigal     
#           filetype = 2  Blocked Binary 
#           filetype = 3  Cbf
#           filetype = 4  Unblocked binary
#           filetype = 5  Ascii
#   Two input files must be present. The merged file is ordered by record startTime. 
#   If output filetype is not specified, filetype = 1 (Madrigal).
#

proc printUsage {} {

puts "Usage: mergeCedarFilesInTime \[options\]"
puts "  Options:"
puts "      -i file rec1 rec2    Add records rec1 to rec2 of file to outFile"
puts "      -o outFile"
puts "      -t fileType          set type of outFile to fileType"
puts "          filetype = 1  Madrigal"
puts "          filetype = 2  Blocked Binary "
puts "          filetype = 3  Cbf"
puts "          filetype = 4  Unblocked binary"
puts "          filetype = 5  Ascii"
puts "Two input files must be present. The merged file is ordered by record startTime. "
puts "If output filetype is not specified, filetype = 1 (Madrigal)."

    return 0 
}

# Get parameter codes
cedarCode cedarCode

# Get number of parameters
set nargs $argc
if {$nargs <4 } {
    printUsage
    exit
}

set i 0
set infiles {}
set rec1s {}
set rec2s {}
set filetype 20
set isinfile 0
set isoutfile 0
while {$i < $nargs} {

    set option [lindex $argv $i]

    if {$option == "-i"} {
        incr i
        if {$i == $nargs} {
            puts "Option $option requires more arguments"
            return -1
        }
        set infiles [lappend infiles [lindex $argv $i]]
        incr i
        if {$i == $nargs} {
            puts "Option $option requires more arguments"
            printUsage
            return -1
        }
        if {[regexp {^[0-9]+$} [lindex $argv $i]] == 0} {
            puts "Error: bad input file record range"
            printUsage
            return -1
        }

        if {[lindex $argv $i] == 0} {
            puts "Error: first record must be 1 or greater"
            return -1
        }

        set rec1s [lappend rec1s [lindex $argv $i]]
        incr i
        if {$i == $nargs} {
            puts "Option $option requires more arguments"
            return -1
        }
        if {[regexp {^[0-9]+$} [lindex $argv $i]] == 0} {
            puts "Error: bad input file record range"
            printUsage
            return -1
        }
        set rec2s [lappend rec2s [lindex $argv $i]]
        incr i
        set isinfile 1

    } elseif {$option == "-o"} {
        incr i
        if {$i == $nargs} {
            puts "Option $option requires more arguments"
            return -1
        }
        set outfile [lindex $argv $i]
        incr i
        set isoutfile 1

    } elseif {$option == "-t"} {
        incr i
        if {$i == $nargs} {
            puts "Option $option requires more arguments"
            return -1
        }
        set filetype [expr 19 + [lindex $argv $i]]
        incr i

    } else {
        puts "Error: Unknown option $option"
        return -1
    }

}

if {$isinfile == 0} {
    puts "Error: input file not specified"
    printUsage
    return -1
}

if {[llength $infiles] != 2} {
    puts "Error: exactly 2 input files must be specified"
    printUsage
    return -1
}

if {$isoutfile == 0} {
    puts "Error: output file not specified"
    printUsage
    return -1
}

# Create madrec object for the output file.
mad madout
set status [catch {$madout open $filetype $outfile}]
if {$status != 0} {
    puts "mad open Error: [$madout get error]"
    exit
}


# Create madrec object for the input file. Specify file type 1 for
# automatic determination of the CEDAR file type
mad madin0
mad madin1
set infile0 [lindex $infiles 0]
set infile1 [lindex $infiles 1]
set rec1_0 [lindex $rec1s 0]
set rec2_0 [lindex $rec2s 0]
set rec1_1 [lindex $rec1s 1]
set rec2_1 [lindex $rec2s 1]

if {[file exists $infile0]} {
    catch [$madin0 open 1 $infile0]
    if {$status != 0} {
        puts "mad open Error: [$madin0 get error]"
        exit
    }
} else {
    puts "Input file $infile0 does not exist"
    exit
}

if {[file exists $infile1]} {
    catch [$madin1 open 1 $infile1]
    if {$status != 0} {
        puts "mad open Error: [$madin1 get error]"
        exit
    }
} else {
    puts "Input file $infile1 does not exist"
    exit
}

set file0ready 0
set file1ready 0
set j0 0          
set j1 0

# Skip the first rec1_0 records
for {set j 0} {$j < [expr $rec1_0 ]} {incr j} {
    $madin0 getNextRecord
    set file0ready 1
    set j0 1
}

# Skip the first rec1_1 records
for {set j 0} {$j < [expr $rec1_1 ]} {incr j} {
    $madin1 getNextRecord
    set file1ready 1
    set j1 1
}


set file0done 0 
set file1done 0 
set done 0
while {1} {

    # getNextRecord for whatever file needs it
    if {$file0done == 0 && $file0ready == 0 && ([expr $rec2_0 - $rec1_0] >= $j0)} {
        if {[set status [$madin0 getNextRecord]] != 0} {
            # puts "file 0 done"
            set file0done 1
            set file0ready 0
        } else {
            set file0ready 1
            incr j0
        }
    }

    if {$file1done == 0 && $file1ready == 0 && ([expr $rec2_1 - $rec1_1] >= $j1)} {
        if {[set status [$madin1 getNextRecord]] != 0} {
            # puts "file 1 done"
            set file1done 1
            set file1ready 0
        } else {
            set file1ready 1
            incr j1
        }
    }

    # check if done
    if {($file0done == 1 && $file1done == 1) ||
        ($j0 > [expr $rec2_0 - $rec1_0] && $j1 > [expr $rec2_1 - $rec1_1]) ||
        ($file0ready == 0 && $file1ready == 0) } {
	set done 1
    }

    # find key for both records
    if {$file0ready == 1} {
        set madST0 [$madin0 get startTime]
        set madST0List [split $madST0]
        set madST0 [join $madST0]
        set madST0List [split $madST0]
        set madST0Key [getKey [lindex $madST0List 0] [lindex $madST0List 1] [lindex $madST0List 2] [lindex $madST0List 3] [lindex $madST0List 4] [lindex $madST0List 5]]
    }

    if {$file1ready == 1} {
        set madST1 [$madin1 get startTime]
        set madST1List [split $madST1]
        set madST1 [join $madST1]
        set madST1List [split $madST1]
        set madST1Key [getKey [lindex $madST1List 0] [lindex $madST1List 1] [lindex $madST1List 2] [lindex $madST1List 3] [lindex $madST1List 4] [lindex $madST1List 5]]
    }


    # now write only one of the two files
    if {$file1ready == 0 && $file0ready == 1} {
        # must write file 0
	$madin0 copy $madout
	$madout putNextRecord
        set file0ready 0
        # puts "just wrote from file 0: $j0"
    } elseif {$file0ready == 0 && $file1ready == 1} {
        # must write file 1
	$madin1 copy $madout
	$madout putNextRecord
        set file1ready 0
        # puts "just wrote from file 1: $j1"
    } else {
        # both are ready
        if {$madST1Key > $madST0Key && $file0ready == 1} {
            # write file 0
            $madin0 copy $madout
	    $madout putNextRecord
            set file0ready 0
            # puts "just wrote from file 0: $j0"
        } elseif {$file1ready == 1} {
            # write file 1
            $madin1 copy $madout
	    $madout putNextRecord
            set file1ready 0
            # puts "just wrote from file 1: $j1"
        }
    }

    if {($done) && ($file0ready == 0) && ($file1ready == 0)} {
        break
    }
}

# output totals
puts "Number of records added from first file: $j0"
puts "Number of records added from second file: $j1"

# Close first input file and destroy madrec object
$madin0 close
$madin0 destroy

# Close second input file and destroy madrec object
$madin1 close
$madin1 destroy

# Close output file and destroy madrec object
$madout close
$madout destroy
