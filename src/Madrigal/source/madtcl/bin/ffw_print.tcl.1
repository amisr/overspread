proc ffw_print {argc argv} {
    
    # ffw_print prints a flattened subset of the data in a CEDAR File.
    # The file may be any of the 5 supported CEDAR formats (Madrigal, Blocked
    # Binary, Cbf, Unblocked Binary or ASCII"), and may include any mixture
    # of prologue, header and data records. The format of the file is
    # determined automatically.

    global mad
    global infile printParmsIn filterParmsIn filterMinsIn filterMaxsIn
    global cedarCode
    global printDestination

    set debug 1
    
    # Get print parameter codes
    # Ignore parameter names which cedarCode does not recognize
    set printCodesRequested {}
    set numCodes [$cedarCode numCodes]
    for {set i 0} {$i < $numCodes} {incr i} {
	set code [$cedarCode code $i]
	set mnemonic [string trim [$cedarCode mnemonic $code]]
	foreach printParm $printParmsIn {
	    if {[string compare $printParm $mnemonic] == 0} {
		set printCodesRequested [lappend printCodesRequested $code]
		break
	    }
	}
    }
    
    # Get filter parameter codes
    # Ignore parameter names which cedarCode does not recognize
    set filterCodesRequested {}
    set filterMinsRequested {}
    set filterMaxsRequested {}
    set numCodes [$cedarCode numCodes]
    #puts "numCodes = $numCodes"
    for {set i 0} {$i < $numCodes} {incr i} {
	set code [$cedarCode code $i]
	set mnemonic [string trim [$cedarCode mnemonic $code]]
	set j 0
	foreach filterParm $filterParmsIn {
	    if {[string compare $filterParm $mnemonic] == 0} {
		set filterCodesRequested [lappend filterCodesRequested $code]
		set filterMinsRequested \
		    [lappend filterMinsRequested [lindex $filterMinsIn $j]]
		set filterMaxsRequested \
		    [lappend filterMaxsRequested [lindex $filterMaxsIn $j]]
		break
	    }
	    incr j
	}
    }

    if {$debug == 1} {    
        puts "printCodesRequested = $printCodesRequested"
        puts "filterCodesRequested = $filterCodesRequested"
        puts "filterMinsRequested = $filterMinsRequested"
        puts "filterMaxsRequested = $filterMaxsRequested"
    }
    
    # Get list of parameters in the file
    for {set i 0} {$i<100} {incr i} {
	set status [$mad getNextRecord]
	if {$status != 0} {
	    if {$status == "No errors"} {
		break
	    } else {
		puts "Error reading $infile"
		exit
	    }      
	}
	set pc {}
	set pc1d [$mad get parcodes1d]
	foreach parCode $pc1d {
	    if {[lsearch $pc $parCode] == -1} {
		set pc [lappend pc $parCode]
	    }
	}
	set pc2d [$mad get parcodes2d]
	foreach parCode $pc2d {
	    if {[lsearch $pc $parCode] == -1} {
		set pc [lappend pc $parCode]
	    }
	}
    }
    
    # Specify printable derived parameters
    set pc1dx {}
    set pc1dx [lappend pc1dx 34]
    set pc2dx {}
    #puts "pc1dx = $pc1dx"
    
    set missing [$mad get missing]
    
    # Close and reopen the file
    $mad close
    catch [$mad open 3 $infile]
    if {[$mad get fileType] == -1} {
	puts "Error: $infile is not a valid Cedar file type"
	exit
    }
    
    # Locate print codes
    set printCodes {}
    set printCodeLocations {}
    set printCodeFormats {}
    foreach pcr $printCodesRequested {
    #puts "pcr = $pcr"
	if {[lsearch $pc1d $pcr] >= 0} {
	    set printCodes [lappend printCodes $pcr]
	    set printLocations [lappend printLocations "1d"]
	    set printFormats [lappend printFormats [$cedarCode format $pcr]]
	} elseif {[lsearch $pc2d $pcr] >= 0} {
	    set printCodes [lappend printCodes $pcr]
	    set printLocations [lappend printLocations "2d"]
	    set printFormats [lappend printFormats [$cedarCode format $pcr]]
	} elseif {[lsearch $pc1dx $pcr] >= 0} {
	    set printCodes [lappend printCodes $pcr]
	    set printLocations [lappend printLocations "1dx"]
	    set printFormats [lappend printFormats [$cedarCode format $pcr]]
	} elseif {[lsearch $pc2dx $pcr] >= 0} {
	    set printCodes [lappend printCodes $pcr]
	    set printLocations [lappend printLocations "2dx"]
	    set printFormats [lappend printFormats [$cedarCode format $pcr]]
	}
    }
    #puts "printCodes = $printCodes"
    #puts "printFormats = $printFormats"
    #puts "printLocations = $printLocations"
    
    # Locate filter codes
    set filterCodes {}
    set filterLocations {}
    set filterMins {}
    set filterMaxs {}
    set j 0
    foreach fcr $filterCodesRequested {
	#puts "fcr = $fcr"
	if {[lsearch $pc1d $fcr] >= 0} {
	    set filterCodes [lappend filterCodes $fcr]
	    set filterLocations [lappend filterLocations "1d"]
	    set filterMins [lappend filterMins [lindex $filterMinsRequested $j]]
	    set filterMaxs [lappend filterMaxs [lindex $filterMaxsRequested $j]]
	} elseif {[lsearch $pc2d $fcr] >= 0} {
	    set filterCodes [lappend filterCodes $fcr]
	    set filterLocations [lappend filterLocations "2d"]
	    set filterMins [lappend filterMins [lindex $filterMinsRequested $j]]
	    set filterMaxs [lappend filterMaxs [lindex $filterMaxsRequested $j]]
	} elseif {[lsearch $pc1dx $fcr] >= 0} {
	    set filterCodes [lappend filterCodes $fcr]
	    set filterLocations [lappend filterLocations "1dx"]
	    set filterMins [lappend filterMins [lindex $filterMinsRequested $j]]
	    set filterMaxs [lappend filterMaxs [lindex $filterMaxsRequested $j]]
	} elseif {[lsearch $pc2dx $fcr] >= 0} {
	    set filterCodes [lappend filterCodes $fcr]
	    set filterLocations [lappend filterLocations "2dx"]
	    set filterMins [lappend filterMins [lindex $filterMinsRequested $j]]
	    set filterMaxs [lappend filterMaxs [lindex $filterMaxsRequested $j]]
	}
	incr j
    }
    #puts "filterCodes = $filterCodes"
    #puts "filterLocations = $filterLocations"
    #puts "filterMins = $filterMins"
    #puts "filterMaxs = $filterMaxs"
    
    # Print specified data in flat file format
    $mad close
    catch [$mad open 1 $infile]
    if {[$mad get fileType] == -1} {
	puts "Error: $infile is not a valid Cedar file type"
	exit
    }
    
    # Loop over records
    for {set i 0} {$i<10} {incr i} {
	set status [$mad getNextRecord]
	if {$status != 0} {
	    if {$status == "No errors"} {
		break
	    } else {
		puts "Error reading $infile"
		exit
	    }      
	}
    
	set parm1dx {}
    
	if {$i == 0} {
	    set startJday0 [$mad get startJday]
	}
    
	# Get time parameters from prolog
	set startJday [$mad get startJday]
	set endJday [$mad get endJday]
	set ut1 [expr 24.0*($startJday - int($startJday0))]
	set ut2 [expr 24.0*($endJday - int($startJday0))]
	set uth [expr 0.5*($ut1 + $ut2)]
	set parm1dx [lappend parm1dx $uth]
    
	# Check whether record passes filter
	set print 1
	set ncodes [llength $filterCodes]
	for {set k 0} {$k < $ncodes} {incr k} {
	    set filterCode [lindex $filterCodes $k]
	    set filterLocation [lindex $filterLocations $k]
	    set filterMin [lindex $filterMins $k]
	    set filterMax [lindex $filterMaxs $k]
	    if {$filterLocation == "1d"} {
		set parmVal [$mad get parm1d $filterCode]
	    } elseif {$filterLocation == "1dx"} {
		set parmVal [lindex $parm1dx [lsearch $pc1dx $filterCode]]
	    } else {
		continue
	    }
	    if {$parmVal < $filterMin} {
		#puts "1d Filter reject: $parmVal $filterMin $filterMax"
		set print 0
	    }
	    if {$parmVal > $filterMax} {
		#puts "1d Filter reject: $parmVal $filterMin $filterMax"
		set print -1
	    }
	}
	if {$print == 0} {continue}
	if {$print == -1} {break}
    
	# Loop over rows of 2D array printing the specified parameters
	set jpar [$mad get jpar]
	for {set j 0} {$j<$jpar} {incr j} {
    
	    # Check whether row passes filter
	    set print 1
	    set ncodes [llength $filterCodes]
	    for {set k 0} {$k < $ncodes} {incr k} {
		set filterCode [lindex $filterCodes $k]
		set filterLocation [lindex $filterLocations $k]
		set filterMin [lindex $filterMins $k]
		set filterMax [lindex $filterMaxs $k]
		if {$filterLocation == "2d"} {
		    set parmVal [lindex [$mad get parm2d $filterCode] $j]
		} elseif {$filterLocation == "2dx"} {
		    set parmVal [lindex $parm2dx [lsearch $pc2dx $filterCode]]
		} else {
		    continue
		}
		if {$parmVal < $filterMin || $parmVal > $filterMax} {
		    #puts " 2d Filter reject: $parmVal $filterMin $filterMax"
		    set print 0
		    break
		}
	    }
	    if {$print == 0} {
		continue
	    }
    
	    # Assemble output line
	    set line ""
	    set ncodes [llength $printCodes]
	    for {set k 0} {$k < $ncodes} {incr k} {
		set printCode [lindex $printCodes $k]
		set printFormat [lindex $printFormats $k]
		set printLocation [lindex $printLocations $k]
		if {$printLocation == "1d"} {
		    set parmVal [$mad get parm1d $printCode]
		    set parmString [format $printFormat $parmVal]
		} elseif {$printLocation == "2d"} {
		    set parmVal [$mad get parm2d $printCode]
		    set parmString [format $printFormat [lindex $parmVal $j]]
		} elseif {$printLocation == "1dx"} {                
		    set parmVal [lindex $parm1dx [lsearch $pc1dx $printCode]]
		    set parmString [format $printFormat $parmVal]
		} elseif {$printLocation == "2dx"} {
		    set parmVal 0.0
		    set parmString [format $printFormat [lindex $parmVal $j]]
		} else {
		    set parmString [format $printFormat $missing]
		}
		set line $line$parmString
	    }
            if {![info exists printDestination]} {
	         puts $line
            } else {
                $printDestination insert end $line\n
            }
	}
    }

}
