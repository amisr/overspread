#!/bin/sh
# The madtclsh path is longer than 32 characters. So, we take advantage
# of the fact that a backslash continues a comment line in tcl \
exec MADROOT/bin/madtclsh "$0" ${1+"$@"}


# UpdateDstparms reads a dst file and adds
# the indices to the new-stype Madrigal DST parameter file. The
# new style Madrigal DST parameter file has 24 records per day,
# so that each 1-hour period has its own record, in accord with the
# Cedar standard.  The old style had one record per day, with 24 2D records
# with different times, in conflict with the prolog times.  The new
# style DST file is generally called dst570101g.002, and the old
# style dst570101g.001, although this is not enforced.  If a DST value is
# already in the DST parameter file, it is replaced.
#
# The DST data are located at :
#     ftp://ftp.ngdc.noaa.gov/STP/GEOMAGNETIC_DATA/INDICES/DST/
#
# Usage: updateDstparms \[options\]
#   Options:
#     -i dstFileIn     Original DST parameter file
#     -o dstFileOut    Updated DST parameter file
#     -d dstFile       New DST file to add to original
#     -h               Help information
#   If the -o option is omitted, dstFileOut = ./dstFileOut
#   If  -d is omitted, a summary of dstfileIn is displayed.
#   If -d is present, dstfileOut will be
#     updated with the DST parameters in dstFile.
#
# e.g.: updateDstparms -i /opt/madrigal/experiments/1957/dst/01jan50/dst570101g.002 -d dst2002
#

proc printUsage {} {

    puts "Usage: updateDstparms \[options\]"
    puts "  Options:"
    puts "    -i dstFileIn     Original DST parameter file"
    puts "    -o dstFileOut    Updated DST parameter file"
    puts "    -d dstFile       New DST file to add to original"
    puts "    -h               Help information"
    puts "  If the -o option is omitted, dstFileOut = ./dstFileOut"
    puts "  If  -d is omitted, a summary of dstfileIn is displayed."
    puts "  If -d is present, dstfileOut will be updated with the DST parameters in dstFile."

    return 0 
}

set debug 0

# Get number of arguments
set nargs $argc
if {$nargs == 0 || $nargs > 9} {
    printUsage
    exit
}

# Process arguments
set isdstfilein 0
set isdstfileout 0
set isnewfile 0
set i 0
while {$i < $nargs} {
    set option [lindex $argv $i]

    if {$option == "-i"} {
        incr i
        if {$i == $nargs} {
            puts "Error: Option $option requires file name argument"
            printUsage
            return -1
        }
        set dstFileIn [lindex $argv $i]
        incr i
        set isdstfilein 1

    } elseif {$option == "-o"} {
        incr i
        if {$i == $nargs} {
            puts "Option $option requires file name argument"
            printUsage
            return -1
        }
        set dstFileOut [lindex $argv $i]
        incr i
        set isdstfileout 1

    } elseif {$option == "-d"} {
        incr i
        if {$i == $nargs} {
            puts "Option $option requires file name argument"
            printUsage
            return -1
        }
        set newFile [lindex $argv $i]
        incr i
        set isnewfile 1

    } elseif {$option == "-h"} {
        incr i
        printUsage
        return 0

    } else {
        puts "Error: Unknown option $option"
        printUsage
        return -1
    }
}

if {$isdstfilein == 0} {
    printUsage
    return -1
}

puts ""
puts "Input DST parameter file = $dstFileIn"

if {$isdstfileout == 0} {
    puts ""
    puts "Output DST parameter file = ./dstFileOut"
    set dstFileOut "./dstFileOut"
} else {
    puts ""
    puts "Output DST parameter file = $dstFileOut"
}

if {$isnewfile == 1} {
    puts ""
    puts "Input new DST file to add = $newFile"
} else {
    puts ""
    puts "No new DST file"
}


# Get parameter codes
cedarCode cedarCode



# Process new DST parameter file
if {[catch {
    if {$isnewfile == 1} {
        set dstkeys {}
        set dstjdaynos {}
        set dstl {}
        set fpg [open $newFile]
        set j 0
        while {[gets $fpg line] >= 2} {
            # puts "--> $line"
            set year [string range $line 3 4]
	    scan $year %d year
            if {$year >= 50} {
                set year [expr $year + 1900]
            } else {
                set year [expr $year + 2000]
            }
            if {$year < 1950 || $year > 2050} {
                error "Illegal year $year - since 2 digits years used"
            }
            set month [string range $line 5 6]
            if {[string trim $month "0"] < 1 || [string trim $month "0"] > 12} {
                error "Illegal month $month"
            }
            if {[string index $month 0] == "0"} {
	        set month [string trim $month "0"]
            }
            set day [string range $line 8 9]
            if {[string trim $day "0"] < 1 || [string trim $day "0"] > 31} {
                error "Illegal day $day"
            }
            if {[string index $day 0] == "0"} {
	        set day [string trim $day "0"]
            }
            set dstkeys [lappend dstkeys [getKey $year $month $day 0 0 0]]
            set dstjdaynos [lappend dstjdaynos [jday $day $month $year]]
            set i1 20
            set i2 23
            set dst {}
            for {set i 1} {$i < 25} {incr i} {
                set dst1 [string trim [string range $line $i1 $i2]]
		if {[string compare $dst1 "9999"] == 0} {
		    set dst1 -32767
		}
                set dst [lappend dst $dst1]
                set i1 [expr $i1 + 4]
                set i2 [expr $i2 + 4]
            }
           
            if {$j == 0} {
                set firstDateNEW [format "%2.2d/%2.2d/%4d" $month $day $year]
            }
            set dstl [lappend dstl $dst]
            incr j
        }
        set lastDateNEW [format "%2.2d/%2.2d/%4d" $month $day $year]
        set firstJdaynoNEW [lindex $dstjdaynos 0]
        set lastJdaynoNEW [lindex $dstjdaynos [expr [llength $dstjdaynos]-1]]

        puts ""
        puts "New DST parameter file:"
        puts "  First Day: $firstJdaynoNEW  $firstDateNEW"
        puts "   Last Day: $lastJdaynoNEW  $lastDateNEW"
        if {$debug} {
            puts "[llength $dstkeys] DST parameter keys"
            puts $dstkeys
            puts "[llength $dstjdaynos] DST Julian day numbers"
            puts $dstjdaynos
        }
    }

} result]} {
    puts "Error processing new DST parameter file"
    puts $result
    exit
}

# Create madrec object for the input DST parameter file
set status [catch {mad madin}]
if {$status != 0} {
    puts "mad Error: [$madin get error]"
    exit
}
set status [catch {$madin open 1 $dstFileIn}]
if {$status != 0} {
    puts "mad open Error: [$madin get error]"
    exit
}

# Create madrec object for the output DST parameter file
set status [catch {mad madout}]
if {$status != 0} {
    puts "mad Error: [$madout get error]"
    exit
}
set status [catch {$madout open 20 $dstFileOut}]
if {$status != 0} {
    puts "mad open Error: [$madout get error]"
    exit
}

# Create madrec object for the memory image of DST parameter file
set status [catch {mad madmem}]
if {$status != 0} {
    puts "mad Error: [$madmem get error]"
    exit
}
set status [catch {$madmem open 30 $dstFileIn}]
if {$status != 0} {
    puts "mad open Error: [$madmem get error]"
    exit
}

# Print a one line per record summary of the file
#puts ""
#puts "DST parameter file:"
#puts "                 rec jday1       Start Time            End Time       kinst krec kindat"
set rec 0
set jdayl 0

while {[set status [$madin getNextRecord]] == 0} {

    incr rec


    set recno [format %5d $rec]
    set startTime [$madin get startTime]
    set yr1 [lindex $startTime 0]
    set mo1 [lindex $startTime 1]
    set dy1 [lindex $startTime 2]
    set hr1 [lindex $startTime 3]
    set mn1 [lindex $startTime 4]
    set sc1 [lindex $startTime 5]
    set zero 0
    if {[string length $hr1] == 1} {
        set hr1 $zero$hr1
    }
    if {[string length $mn1] == 1} {
        set mn1 $zero$mn1
    }
    if {[string length $sc1] == 1} {
        set sc1 $zero$sc1
    }
    set endTime [$madin get endTime]
    set yr2 [lindex $endTime 0]
    set mo2 [lindex $endTime 1]
    set dy2 [lindex $endTime 2]
    set hr2 [lindex $endTime 3]
    set mn2 [lindex $endTime 4]
    set sc2 [lindex $endTime 5]
    set zero 0
    if {[string length $hr2] == 1} {
        set hr2 $zero$hr2
    }
    if {[string length $mn2] == 1} {
        set mn2 $zero$mn2
    }
    if {[string length $sc2] == 1} {
        set sc2 $zero$sc2
    }
    set startDate [format %2.2d/%2.2d/%2.2d $mo1 $dy1 $yr1]
    set endDate [format %2.2d/%2.2d/%2.2d $mo2 $dy2 $yr2]
    set jday1 [expr int([$madin get startJday])]
    set jday2 [expr int([$madin get endJday])]
    set summary "$recno $jday1 \
             $startDate $hr1:$mn1:$sc1  $endDate $hr2:$mn2:$sc2 \
             [$madin get kinst] \
             [$madin get krec] \
             [$madin get kindat]"
    set summary "$recno $jday1 \
             $startDate $hr1:$mn1:$sc1  $endDate $hr2:$mn2:$sc2 \
             [$madin get kinst] \
             [$madin get 1dInt 330]"
#puts $summary
    if {$jday1 != $jday2} {
        puts "Error in:     $summary"
        puts "    Start and end Julian Day numbers, $jday1 and $jday2 are not the same."
    }
    set jdayl $jday1
    if {$rec == 1} {
        set firstJdaynoOLD $jday1
        set firstDateOLD [format %2.2d/%2.2d/%2.2d $mo1 $dy1 $yr1]
        #puts "First record: $summary"
    }
}
#puts "Exit status = $status"
#puts "Last record:  $summary"

set lastJdaynoOLD $jday1
set lastDateOLD [format %2.2d/%2.2d/%2.2d $mo1 $dy1 $yr1]

puts ""
puts "Original DST parameter file:"
puts "  First Day: $firstJdaynoOLD  $firstDateOLD"
puts "   Last Day: $lastJdaynoOLD  $lastDateOLD"

if {$isnewfile==0} {
    puts "No new DST parameter file - Exiting"
    exit
}


# describe new records to be added, if any
puts ""
if {$lastJdaynoNEW > $lastJdaynoOLD} {
    set firstJdaynoAdd [expr $lastJdaynoOLD+1]
    set lastJdaynoAdd $lastJdaynoNEW
    set d [jdater $firstJdaynoAdd]
    set firstDateAdd [format %2.2d/%2.2d/%2.2d [lindex $d 1] [lindex $d 0] [lindex $d 2]]
    set d [jdater $lastJdaynoAdd]
    set lastDateAdd [format %2.2d/%2.2d/%2.2d [lindex $d 1] [lindex $d 0] [lindex $d 2]]
    puts "Adding new records from $firstDateAdd (jday=$firstJdaynoAdd) to $lastDateAdd (jday=$lastJdaynoAdd)"
    puts "  to original DST parameter file."
} else {
    puts "No new records to be added"
}

# describe whether any DST records will be modified in existing file
puts ""
if {$firstJdaynoNEW < $lastJdaynoOLD} {
    set d [jdater $firstJdaynoNEW]
    set firstDateAdd [format %2.2d/%2.2d/%2.2d [lindex $d 1] [lindex $d 0] [lindex $d 2]]
    if {$lastJdaynoNEW < $lastJdaynoOLD} {
        set lastJdaynoUpNEW $lastJdaynoNEW
    } else {
        set lastJdaynoUpNEW $lastJdaynoOLD
    }
    set d [jdater $lastJdaynoUpNEW]
    set lastDateAdd [format %2.2d/%2.2d/%2.2d [lindex $d 1] [lindex $d 0] [lindex $d 2]]
    puts "Modifying DST data from $firstDateAdd (jday=$firstJdaynoNEW) to $lastDateAdd (jday=$lastJdaynoUpNEW)"
    puts "  in existing DST parameter file."
} 




# Add records to the memory image as necessary
set lprol 16
set jpar 1
set mpar 0
set nrow 0
set krec 1002
set kinst 212
set kindat 30006
set ibyr 2001
set ibmo 8
set ibdy 31
set ibh 0
set ibm 0
set ibs 0
set ibcs 0
set ieyr 2001
set iemo 8
set iedy 31
set ieh 23
set iem 59
set ies 59
set iecs 99
# insert new records only if needed
if {$lastJdaynoNEW > $lastJdaynoOLD} {
    for {set jday $firstJdaynoAdd} {$jday <= $lastJdaynoAdd} {incr jday} {
        # now loop through 24 1 hour periods
        for {set loopHour 0} {$loopHour < 24} {incr loopHour } {
            set d [jdater $jday]
            set ibyr [lindex $d 2]
            set ibmo [lindex $d 1]
            set ibdy [lindex $d 0]
            set ibh $loopHour
            set ieyr $ibyr
            set iemo $ibmo
            set iedy $ibdy
            set ieh $loopHour

            set status [catch {$madmem createRecord $lprol $jpar $mpar $nrow $krec \
			             $kinst $kindat \
			             $ibyr $ibmo $ibdy $ibh $ibm $ibs $ibcs \
			             $ieyr $iemo $iedy $ieh $iem $ies $iecs} result]
            if {$status != 0} {
                puts "createRecord Error: $result"
                exit
            }
            # Initialize all data values to "Missing"
            $madmem set 1dInt 330 -32767 0

            $madmem putNextRecord
        }
    }
} 


if {[llength $dstkeys] > 0} {
    puts ""
    puts "Enter new DST parameter values into output file"
}
set i 0
foreach key $dstkeys {
    # loop through 24 1-hour periods
    for {set loopHour 0} {$loopHour < 24} {incr loopHour } {
        set status [catch {$madmem getRecordByKey [expr $key+[expr $loopHour*3600]]} result]
        if {$status == 0} {
            $madmem set 1dInt 330 [lindex [lindex $dstl $i] $loopHour ] 0
        } else {
            puts "$status $result *"
        }
    }
    incr i
}


# Copy the memory image to the output file
puts ""
puts "Write the output DST parameter file"
$madmem rewind
while {[set status [$madmem getNextRecord]] == 0} {
    $madmem copy $madout
    $madout putNextRecord
}

# Close file and delete madrec object
puts ""
puts "Close all files and exit"
$madin close
$madin destroy
$madout close
$madout destroy
#$madmem destroy


exit

