package provide mtl 1.0

# These procedures implement methods for the classes defined in mtl.sch. The
# class hierarchy is as follows:
#
#                                  madrigal
#                       ----------------------------
#                        |             |          |
#                  madExperiment    madRec    metadata
#                                                 |
#    --------------------------------------------------------------------
#     |      |        |           |           |          |             |
# madExp  madFile  madData  madInstrument  madSite  madDataType   madInventory 
#

#
# madrigal
#

# proc madrigal_print { handle args } {
# proc madrigal_init { handle } {
# proc madrigal_exit { handle } {


#
# metadata
#

# proc metadata_print { handle args } {
# proc metadata_init { handle } {
# proc metadata_exit { handle } {


#
# madExperiment
#

# proc madExperiment_read { handle args } {
# proc madExperiment_write { handle } {
# proc madExperiment_getFileEntries { handle experimentID dataType fileCategory spare1 hasCatalog hasHeader analysisDate analysisTime spare4 spare5 } {
# proc madExperiment_getDataEntries { handle experimentID dataType } {
# proc madExperiment_new { handle experimentName experimentYear experimentMonth experimentDay instrumentCode } {
# proc madExperiment_generateFromFile { handle madrec experimentPath experimentName } {
# proc madExperiment_updateFromFile { handle madrec experimentPath } {
# proc madExperiment_addFile { handle madrec experimentPath fileCategory {status final} } {
# proc madExperiment_addData { handle madrec } {
# proc madExperiment_print { handle args } {
# proc madExperiment_init { handle } {
# proc madExperiment_exit { handle } {


#
# madRec
#

# proc madRec_open { handle fileName } {
# proc madRec_print { handle args } {
# proc madRec_init { handle } {
# proc madRec_exit { handle } {


#
# madInstrument
#

# proc madInstrument_read { handle } {
# proc madInstrument_write { handle } {
# proc madInstrument_getEntries { handle mnemonic name } {
# proc madInstrument_print { handle args } {
# proc madInstrument_init { handle } {
# proc madInstrument_exit { handle } {


#
# madSite
#

# proc madSite_read { handle } {
# proc madSite_write { handle } {
# proc madSite_getEntries { handle name server documentRoot cgiDirectory } {
# proc madSite_print { handle args } {
# proc madSite_init { handle } {
# proc madSite_exit { handle } {


#
# madDataType
#

# proc madDataType_read { handle } {
# proc madDataType_write { handle } {
# proc madDataType_getEntries { handle description } {
# proc madDataType_print { handle args } {
# proc madDataType_init { handle } {
# proc madDataType_exit { handle } {


#
# madExp
#

# proc madExp_read { handle } {
# proc madExp_write { handle } {
# proc madExp_print { handle args } {
# proc madExp_init { handle } {
# proc madExp_exit { handle } {


#
# madFile
#

# proc madFile_read { handle } {
# proc madFile_write { handle } {
# proc madFile_getEntries { handle experimentID dataType category spare1 hasCatalog hasHeader analysisDate analysisTime spare4 spare5 } {
# proc madFile_addFile { handle fileName experimentID dataType category spare1 hasCatalog hasHeader analysisDate analysisTime spare4 spare5 } {
# proc madFile_print { handle args } {
# proc madFile_init { handle } {
# proc madFile_exit { handle } {


#
# madData
#

# proc madData_read { handle } {
# proc madData_write { handle } {
# proc madData_getEntries { handle experimentID dataType } {
# proc madData_addFile { handle day experimentID dataType } {
# proc madData_print { handle args } {
# proc madData_init { handle } {
# proc madData_exit { handle } {


#
# madInventory
#

# proc madInventory_read { handle } {
# proc madInventory_write { handle } {
# proc madInventory_getEntries { handle experimentID dataType } {
# proc madInventory_addFile { handle day experimentID dataType } {
# proc madInventory_print { handle args } {
# proc madInventory_init { handle } {
# proc madInventory_exit { handle } {


#
# Utility procedures
#

# proc calcJulianDay {day month year}
# proc translateCedarFile { infile, outfile }

#
# madrigal
#

package provide mtl 1.0.0

proc madrigal_print { handle args } {
}


proc madrigal_init { handle } {

    global env
    global debug

    if {![info exists debug]} {
        set debug 0
    }

    # Get madroot
    if {[info exists env([string toupper madroot])]} {
        set madroot $env([string toupper madroot])
    } else {
        set madroot /Users/mnicolls/Documents/Work/Madrigal
    }
    $handle configure -madroot $madroot

    # Extract configuration variables from madrigal.cfg
    set fc [open [file join $madroot madrigal.cfg] r]
    while {[gets $fc line] >= 0} {
        if {[regexp -- ^# $line] || [string length $line] == 0} {continue}
        scan $line "%s %s %s" name equals value
        set name [string tolower $name]
        if {$equals == "="} {
            set cmd [list $handle configure -$name \
                     [string range $line [string first $value $line] end]]
            eval $cmd
            set vars [lappend vars $name]
        }
    }
    if {$debug == 2} {
        foreach var $vars {
           puts "$var = [$handle cget -$var]"
        }
    }
}


proc madrigal_exit { handle } {
}



#
# metadata
#

proc metadata_print { handle args } {
}


proc metadata_init { handle } {
    madrigal_init $handle
    set madroot [$handle cget -madroot]
    $handle configure -metadataDir [file join $madroot metadata]
}


proc metadata_exit { handle } {
}


#
# madExperiment
#


proc madExperiment_read { handle args} {
    global debug

    if {$debug} {puts "Entering madExperiment_read"}
    set madroot [$handle cget -madroot]

    if {[llength $args] == 0 } {
        mem $handle expName
    } else {
        set expName [lindex $args 0]
    }

    # Read the experiment table
    set fp [open [file join $madroot experiments $expName expTab.txt]]
    while {[gets $fp line] >= 0} {
        set expItem [split $line ,]
    }
    $handle configure -id [lindex $expItem 0]
    $handle configure -url [lindex $expItem 1]
    $handle configure -name [lindex $expItem 2]
    $handle configure -siteID [lindex $expItem 3]
    $handle configure -startDate [lindex $expItem 4]
    $handle configure -startTime [lindex $expItem 5]
    $handle configure -endDate [lindex $expItem 6]
    $handle configure -endTime [lindex $expItem 7]
    $handle configure -instrumentCode [lindex $expItem 8]
    $handle configure -securityCode [lindex $expItem 9]
    close $fp
    
    # Read the file table
    madFile madFiles
    madFiles configure -metadataDir [file join $madroot experiments $expName]
    madFiles read
    set fileList [madFiles cget -files]
    $handle configure -files $fileList
    delete madFiles

    # Read the data table
    madData maddata
    maddata configure -metadataDir [file join $madroot experiments $expName]
    maddata read
    set dataList [maddata cget -data]
    $handle configure -data $dataList
    delete maddata

    return
}


proc madExperiment_write { handle } {
    global debug
    if {$debug} {puts "Entering madExperiment_write"}
    set madroot [$handle cget -madroot]
    set expName [$handle cget -expName]
    set expPath [$handle cget -expPath]
    # Create the directory if necessary
    file mkdir $expPath

    # Write expTab
    set fp [open [file join $expPath expTab.txt] w]
    set id [$handle cget -id]
    set url [$handle cget -url]
    set name [$handle cget -name]
    set siteID [$handle cget -siteID]
    set startDate [$handle cget -startDate]
    set startTime [$handle cget -startTime]
    set endDate [$handle cget -endDate]
    set endTime [$handle cget -endTime]
    set instrumentCode [$handle cget -instrumentCode]
    set securityCode [$handle cget -securityCode]
    puts -nonewline $fp "$id,"
    puts -nonewline $fp "$url,"
    puts -nonewline $fp "$name,"
    puts -nonewline $fp "$siteID,"
    puts -nonewline $fp "$startDate,"
    puts -nonewline $fp "$startTime,"
    puts -nonewline $fp "$endDate,"
    puts -nonewline $fp "$endTime,"
    puts -nonewline $fp "$instrumentCode,"
    puts $fp "$securityCode"
    close $fp

    # Write fileTab
    madFile madfile
    madfile configure -expPath [$handle cget -expPath]
    madfile configure -files [$handle cget -files]
    madfile write
    delete madfile

    # Write dataTab
    madData maddata
    maddata configure -expPath [$handle cget -expPath]
    maddata configure -data [$handle cget -data]
    maddata write
    delete maddata

    return
}


proc madExperiment_getFileEntries { handle experimentID dataType fileCategory \
                                    spare1 hasCatalog hasHeader \
                                    analysisDate analysisTime \
                                    spare4 spare5 } {
    global debug
    if {$debug} {puts "Entering madExperiment_getFileEntries"}
    upvar 3 $experimentID experimentIDL $dataType dataTypeL \
            $fileCategory fileCategoryL $spare1 spare1L $hasCatalog hasCatalogL \
            $hasHeader hasHeaderL $analysisDate analysisDateL\
            $analysisTime analysisTimeL $spare4 spare4L $spare5 spare5L
    set files [$handle cget -files]
    if {$debug} {
        puts "files = $files"
    }
    array set experimentIDL [lindex $files 0]
    array set dataTypeL [lindex $files 1]
    array set fileCategoryL [lindex $files 2]
    array set spare1L [lindex $files 3]
    array set hasCatalogL [lindex $files 4]
    array set hasHeaderL [lindex $files 5]
    array set analysisDateL [lindex $files 6]
    array set analysisTimeL [lindex $files 7]
    array set spare4L [lindex $files 8]
    array set spare5L [lindex $files 9]
    return
}


proc madExperiment_getDataEntries { handle experimentID dataType } {
    global debug
    if {$debug} {puts "Entering madExperiment_getDataEntries"}
    upvar 3 $experimentID experimentIDL $dataType dataTypeL
    set data [$handle cget -data]
    if {$debug} {
        puts "data = $data"
    }
    array set experimentIDL [lindex $data 0]
    array set dataTypeL [lindex $data 1]
    return
}


proc madExperiment_new { handle experimentName \
                         experimentYear experimentMonth experimentDay \
                         instrumentCode } {
    global debug

    if {$debug} {
       puts "Entering genMadExpNew"
       puts experimentName=$experimentName
       puts experimentYear=$experimentYear
       puts experimentMonth=$experimentMonth
       puts experimentDay=$experimentDay
       puts instrumentCode=$instrumentCode
    }
    
    # Initialization
    set months {jan feb mar apr may jun jul aug sep oct nov dec}
    for {set i 01} {$i<=12} {incr i} {
        set monum([lindex $months $i]) $i
    }
    set madroot [$handle cget -madroot]
    set siteID [$handle cget -siteid]
    madInstrument instruments
    instruments read
    instruments getEntries instrumentMnemonic instrumentName \
                       instrumentLatitude instrumentLongitude \
		       instrumentAltitude contactName contactAddress1 \
		       contactAddress2 contactAddress3 \
		       contactCity contactState contactPostalCode \
		       contactCountry contactTelephone contactEmail
    madSite sites
    sites read
    sites getEntries siteName server documentRoot cgiDirectory

    # Construct 2-character experiment year, month, day strings
    if {$experimentYear >= 2000} {
        set experimentYr [expr $experimentYear-2000]
    } elseif {$experimentYear < 2000} {
        set experimentYr [expr $experimentYear-1900]
    }
    # remove leading zero from $experimentDay since tcl thinks its octal
    if {[string index $experimentDay 0] == 0} {
       set experimentDay [string index $experimentDay 1]
    }
    set experimentYr [format %2.2d $experimentYr]
    set experimentMo [format %2.2d $experimentMonth]
    set experimentDy [format %2.2d $experimentDay]
    set monthName [lindex $months [expr $experimentMonth-1]]

    # Construct default experiment path and experiment directory
    set expName [file join $experimentYear \
                           $instrumentMnemonic($instrumentCode) \
                           $experimentDy$monthName$experimentYr]
    $handle configure -expName $expName
    set expPath [file join $madroot "experiments" $expName]
    $handle configure -expPath $expPath

    # Construct experiment directory name
    set experimentDirectory [file join $madroot \
                                       "experiments" \
                                       $experimentYear \
                                       $instrumentMnemonic($instrumentCode) \
                                       $experimentDy$monthName$experimentYr]

    # Construct experiment table
    set ExperimentID [expr 10000000*$siteID]
    set experimentURL "http://"
    set experimentPath [file join $server($siteID) \
                                  $cgiDirectory($siteID) \
                                  "madtoc" \
                                  $experimentYear \
                                  $instrumentMnemonic($instrumentCode) \
                                  $experimentDy$monthName$experimentYr]
    append experimentURL $experimentPath
    set startDate $experimentYear$experimentMo$experimentDy
    set startTime 000000
    set endDate $startDate
    set endTime 235959

    $handle configure -id $ExperimentID
    $handle configure -url $experimentURL
    $handle configure -name $experimentName
    $handle configure -siteID $siteID
    $handle configure -startDate $startDate
    $handle configure -startTime $startTime
    $handle configure -endDate $endDate
    $handle configure -endTime $endTime
    $handle configure -instrumentCode $instrumentCode
    $handle configure -securityCode 0
    delete instruments
    delete sites
    return
}


proc madExperiment_generateFromFile { handle madrec experimentPath \
                                      experimentName } {
    global debug
    if {$debug} {puts "Entering madExperiment_generateFromFile"}

    # Initialization
    set madroot [$handle cget -madroot]
    set siteID [$handle cget -siteid]
    set madserver [$handle cget -madserver]
    set madservercgi [$handle cget -madservercgi]

    # Construct experiment directory name
    set experimentDirectory [file join $madroot "experiments" $experimentPath]
    $handle configure -expName $experimentPath
    $handle configure -expPath $experimentDirectory

    # Construct experiment table
    set ExperimentID [expr 10000000*$siteID]
    set experimentURL "http://"
    set experimentPath [file join $madserver \
                                  $madservercgi \
                                  "madtoc" \
                                  $experimentPath]
    append experimentURL $experimentPath

    $handle configure -id $ExperimentID
    $handle configure -url $experimentURL
    $handle configure -name $experimentName
    $handle configure -siteID $siteID
    $handle configure -securityCode 0

    $handle updateFromFile madrec $experimentPath

    return

}


proc madExperiment_updateFromFile { handle madrec experimentPath} {
    global debug
    if {$debug} {puts "Entering madExperiment_updateFromFile"}

    # Initialization
    set madroot [$handle cget -madroot]

    # Get experiment parameters from file
    set startYear [$madrec cget -startYear]
    set startMonth [$madrec cget -startMonth]
    set startDay [$madrec cget -startDay]
    set startHour [$madrec cget -startHour]
    set startMinute [$madrec cget -startMinute]
    set startSecond [$madrec cget -startSecond]
    set endYear [$madrec cget -endYear]
    set endMonth [$madrec cget -endMonth]
    set endDay [$madrec cget -endDay]
    set endHour [$madrec cget -endHour]
    set endMinute [$madrec cget -endMinute]
    set endSecond [$madrec cget -endSecond]
    set kinst [$madrec cget -kinst]

    # Update experiment table attributes
    $handle configure -startDate $startYear$startMonth$startDay
    $handle configure -startTime $startHour$startMinute$startSecond
    $handle configure -endDate $endYear$endMonth$endDay
    $handle configure -endTime $endHour$endMinute$endSecond
    $handle configure -instrumentCode $kinst

    return
}


proc madExperiment_addFile { handle madrec experimentPath fileCategory {status final} } {
    global debug
    if {$debug} {
        puts "Entering madExperiment_addFile"
	puts handle=$handle 
	puts madrec=$madrec 
	puts experimentPath=$experimentPath 
	puts fileCategory=$fileCategory
    }
    # Initialization

    # Construct experiment directory name
    set madroot [$handle cget -madroot]
    set experimentDirectory [file join $madroot "experiments" $experimentPath]
    $handle configure -expName $experimentPath
    $handle configure -expPath $experimentDirectory

    # Get parameters from file
    set fileName ""
    catch {set fileName [file tail [$madrec cget -fileName]]}
    if { [string length $fileName] < 1 } {
        set fileName $madrec
    }

    set experimentDirectory [$handle cget -expPath]
    
    # see if this is a future realtime file
    if {[file exists $fileName] == 0 && $fileCategory == 4} {
	set futureRT 1
	set kindat 0
    } else {
	set futureRT 0
	set startJulianDay [$madrec cget -startJulianDay]
        set endJulianDay [$madrec cget -endJulianDay]
        set kindat [$madrec cget -kindat]
    }

    # Get fileTab entries
    set files [$handle cget -files]
    
    if {$futureRT == 0} {
        set thisHasCatalog [$madrec cget -hasCatalog]
        set thisHasHeader [$madrec cget -hasHeader]
    } else {
        set thisHasCatalog 0
        set thisHasHeader 0
    }

    # Append entries for this file
    set experimentID [lindex $files 0]
    set experimentID [lappend experimentID $fileName]
    set experimentID [lappend experimentID 0]
    set dataType [lindex $files 1]
    set dataType [lappend dataType $fileName]
    set dataType [lappend dataType $kindat]
    set category [lindex $files 2]
    set category [lappend category $fileName]
    set category [lappend category $fileCategory]
    set spare1 [lindex $files 3]
    set spare1 [lappend spare1 $fileName]
    set spare1 [lappend spare1 0]
    set hasCatalog [lindex $files 4] 
    set hasCatalog [lappend hasCatalog $fileName]
    set hasCatalog [lappend hasCatalog $thisHasCatalog]
    set hasHeader [lindex $files 5]
    set hasHeader [lappend hasHeader $fileName]
    set hasHeader [lappend hasHeader $thisHasHeader]
    set analysisDate [lindex $files 6]
    set analysisDate [lappend analysisDate $fileName]
    set analysisDate [lappend analysisDate 0]
    set analysisTime [lindex $files 7]
    set analysisTime [lappend analysisTime $fileName]
    set analysisTime [lappend analysisTime 0]
    set spare4 [lindex $files 8]
    set spare4 [lappend spare4 $fileName]
    set spare4 [lappend spare4 $status]
    set spare5 [lindex $files 9]
    set spare5 [lappend spare5 $fileName]
    set spare5 [lappend spare5 0]

    # Update fileTab
    $handle configure -files [list $experimentID \
                                   $dataType \
                                   $category \
                                   $spare1 \
                                   $hasCatalog \
                                   $hasHeader \
                                   $analysisDate \
                                   $analysisTime \
                                   $spare4 \
                                   $spare5]


    if {$futureRT == 0} {
        # Copy file to experiment directory
        set infile [$madrec cget -fileName]
        set outfile [file join $experimentDirectory $fileName]
        file mkdir $experimentDirectory
        #file copy -force $infile $outfile
        translateCedarFile $infile $outfile 2
    }
    
    if {$futureRT == 1} {
	set tmp [$handle cget -startDate]
	set year [string range $tmp 0 3]
	set month [string range $tmp 4 5]
	set day [string range $tmp 6 7]
	set startJulianDay [calcJulianDay $year $month $day]
	set endJulianDay [calcJulianDay $year $month $day]
    }

	

    # Get dataTab entries
    set data [$handle cget -data]
    

    # Append entries for this file
    set experimentID [lindex $data 0]
    set dataType [lindex $data 1]
    set nel [llength $experimentID]
    for {set day $startJulianDay} {$day <= $endJulianDay} {incr day} {
        set newEntry 1
        for {set i 0} {$i<$nel} {set i [expr $i+2]} {
            set day0 [lindex $dataType $i]
            set dataType0 [lindex $dataType [expr $i+1]]
            if {$day==$day0 && $kindat==$dataType0} {
                set newEntry 0
            }
        }
        if {$newEntry == 1} {
            set experimentID [lappend experimentID $day]
            set experimentID [lappend experimentID 0]
            set dataType [lappend dataType $day]
            set dataType [lappend dataType $kindat]
        }
    }

    # Update dataTab
    $handle configure -data [list $experimentID $dataType]


    return
}


proc madExperiment_print { handle args } {
    global debug
    if {$debug} {puts "Entering madExperiment_print"}
    set id [$handle cget -id]
    set url [$handle cget -url]
    set name [$handle cget -name]
    set siteID [$handle cget -siteID]
    set startDate [$handle cget -startDate]
    set startTime [$handle cget -startTime]
    set endDate [$handle cget -endDate]
    set endTime [$handle cget -endTime]
    set instrumentCode [$handle cget -instrumentCode]
    set securityCode [$handle cget -securityCode]
    set expName [$handle cget -expName]
    set expPath [$handle cget -expPath]
    set files [$handle cget -files]
    set data [$handle cget -data]
    puts "id = $id"
    puts "url = $url"
    puts "name = $name"
    puts "siteID = $siteID"
    puts "startDate = $startDate"
    puts "startTime = $startTime"
    puts "endDate = $endDate"
    puts "endTime = $endTime"
    puts "instrumentCode = $instrumentCode"
    puts "securityCode = $securityCode"
    puts "expName = $expName"
    puts "expPath = $expPath"
    puts "files = $files"
    puts "data = $data"
    return 0
}


proc madExperiment_init { handle } {
    global debug
    madrigal_init $handle
    if {$debug} {puts "Entering madExperiment_init"}
}


proc madExperiment_exit { handle } {
}


#
# madRec
#

proc madRec_open { handle fileName mad} {
    global debug
    if {$debug} {puts "Entering madRec_open"}

    # Initialization
    upvar 3 $mad madin

    # Get experiment parameters from file
    mad madin
    if {[file exists $fileName]} {
        if [catch {$madin open 1 $fileName}] {
            puts "Cannot open file $fileName"
            exit
        }
    } else {
        puts "File $fileName does not exist"
        exit
    }
    # Three I.S. radars have multiple antennas. Each antenna has its own
    # instrument code (31-32 Millstone, 41-43 St Santin, 71-74 EISCAT).
    # When a file contains data from more than one instrument, a special
    # instrument code (30, 40, 70) is used to refer to the file as a whole.
    # So, we need some special code to deal with this situation.
    set kinst31 0
    set kinst32 0
    set kinst41 0
    set kinst42 0
    set kinst43 0
    set kinst71 0
    set kinst72 0
    set kinst73 0
    set kinst74 0
    set rec 0
    while {[set status [$madin getNextRecord]] == 0} {
	incr rec
	set recno [format %4d $rec]
	set startTime [$madin get startTime]
        if {$rec == 1} {
	    set yr1 [format %4.4d [lindex $startTime 0]]
	    set mo1 [format %2.2d [lindex $startTime 1]]
	    set dy1 [format %2.2d [lindex $startTime 2]]
	    set hr1 [format %2.2d [lindex $startTime 3]]
	    set mn1 [format %2.2d [lindex $startTime 4]]
	    set sc1 [format %2.2d [lindex $startTime 5]]
        }
	set endTime [$madin get endTime]
	set yr2 [format %4.4d [lindex $endTime 0]]
	set mo2 [format %2.2d [lindex $endTime 1]]
	set dy2 [format %2.2d [lindex $endTime 2]]
	set hr2 [format %2.2d [lindex $endTime 3]]
	set mn2 [format %2.2d [lindex $endTime 4]]
	set sc2 [format %2.2d [lindex $endTime 5]]
        set kinst [$madin get kinst]
        set kindat [$madin get kindat]
        set krec [$madin get krec]
        if {$kinst == 31} {set kinst31 1}
        if {$kinst == 32} {set kinst32 1}
        if {$kinst == 41} {set kinst41 1}
        if {$kinst == 42} {set kinst42 1}
        if {$kinst == 43} {set kinst43 1}
        if {$kinst == 71} {set kinst71 1}
        if {$kinst == 72} {set kinst72 1}
        if {$kinst == 73} {set kinst73 1}
        if {$kinst == 74} {set kinst74 1}
        if {$debug == 3} {
	    puts "$recno  $mo1/$dy1/$yr1 $hr1:$mn1:$sc1 \
                          $mo2/$dy2/$yr2 $hr2:$mn2:$sc2 \
	         [$madin get kinst] \
	         [$madin get krec] \
	         [$madin get kindat]"
        }
    }
    if {[expr $kinst31+$kinst32] > 1} {set kinst 30}
    if {[expr $kinst41+$kinst42+$kinst43] > 1} {set kinst 40}
    if {[expr $kinst71+$kinst72+$kinst73+$kinst74] > 1} {set kinst 70}
    if {$debug} {
        puts "$rec records read. kinst=$kinst,kindat=$kindat"
    }

    $handle configure -fileName $fileName
    $handle configure -startYear $yr1
    $handle configure -startMonth $mo1
    $handle configure -startDay $dy1
    $handle configure -startHour $hr1
    $handle configure -startMinute $mn1
    $handle configure -startSecond $sc1
    $handle configure -endYear $yr2
    $handle configure -endMonth $mo2
    $handle configure -endDay $dy2
    $handle configure -endHour $hr2
    $handle configure -endMinute $mn2
    $handle configure -endSecond $sc2
    $handle configure -startJulianDay [calcJulianDay $yr1 $mo1 $dy1]
    $handle configure -endJulianDay [calcJulianDay $yr2 $mo2 $dy2]
    $handle configure -kinst $kinst
    $handle configure -kindat $kindat
    $handle configure -mad $madin

    # Close file and delete madrec object
    $madin close
    
    # open in summary form to get hasCatalog and hasHeader
    $madin open 30 $fileName
    set thisHasCatalog [$madin hasCatalog]
    set thisHasHeader [$madin hasHeader]
    $handle configure -hasCatalog $thisHasCatalog
    $handle configure -hasHeader $thisHasHeader
    $madin close
    
    $madin open 1 $fileName
    return
}


proc madRec_print { handle args } {
}


proc madRec_init { handle } {
    global debug
    madrigal_init $handle
    if {$debug} {puts "Entering madRec_init"}
}


proc madRec_exit { handle } {
    set command [$handle cget -mad]
    # $command getNextRecord
    # puts "startTime = [$command get startTime]"
    $command close
    $command destroy
    return
}


proc madInstrument_read { handle } {
    global debug
    if {$debug} {puts "Entering madInstrument_read"}
    set madroot [$handle cget -madroot]
    set fp [open [file join $madroot metadata instTab.txt] r]
    set mnemonic {}
    set name {}
    while {[gets $fp line] >= 0} {
	set instItem [split $line ","]
	set mnemonic [lappend mnemonic [lindex $instItem 0]]
	set mnemonic [lappend mnemonic [lindex $instItem 1]]
	set name [lappend name [lindex $instItem 0]]
	set name [lappend name [lindex $instItem 2]]
	set latitude [lappend latitude [lindex $instItem 0]]
        if {[catch {format %8.2f [lindex $instItem 3]}]} {
 	    set latitude [lappend latitude -32767]
        } else {
	    set latitude [lappend latitude [lindex $instItem 3]]
        }
        set longitude [lappend longitude [lindex $instItem 0]]
        if {[catch {format %8.2f [lindex $instItem 4]}]} {
 	    set longitude [lappend longitude -32767]
        } else {
	    set longitude [lappend longitude [lindex $instItem 4]]
        }
	set altitude [lappend altitude [lindex $instItem 0]]
        if {[catch {format %8.2f [lindex $instItem 5]}]} {
 	    set altitude [lappend altitude -32767]
        } else {
	    set altitude [lappend altitude [lindex $instItem 5]]
        }
	set contactName [lappend contactName [lindex $instItem 0]]
	set contactName [lappend contactName [lindex $instItem 6]]
	set contactAddress1 [lappend contactAddress1 [lindex $instItem 0]]
	set contactAddress1 [lappend contactAddress1 [lindex $instItem 7]]
	set contactAddress2 [lappend contactAddress2 [lindex $instItem 0]]
	set contactAddress2 [lappend contactAddress2 [lindex $instItem 8]]
	set contactAddress3 [lappend contactAddress3 [lindex $instItem 0]]
	set contactAddress3 [lappend contactAddress3 [lindex $instItem 9]]
	set contactCity [lappend contactCity [lindex $instItem 0]]
	set contactCity [lappend contactCity [lindex $instItem 10]]
	set contactState [lappend contactState [lindex $instItem 0]]
	set contactState [lappend contactState [lindex $instItem 11]]
	set contactPostalCode [lappend contactPostalCode [lindex $instItem 0]]
	set contactPostalCode [lappend contactPostalCode [lindex $instItem 12]]
	set contactCountry [lappend contactCountry [lindex $instItem 0]]
	set contactCountry [lappend contactCountry [lindex $instItem 13]]
	set contactTelephone [lappend contactTelephone [lindex $instItem 0]]
	set contactTelephone [lappend contactTelephone [lindex $instItem 14]]
	set contactEmail [lappend contactEmail [lindex $instItem 0]]
	set contactEmail [lappend contactEmail [lindex $instItem 15]]
    }
    $handle configure -mnemonic $mnemonic
    $handle configure -name $name
    $handle configure -latitude $latitude
    $handle configure -longitude $longitude
    $handle configure -altitude $altitude
    $handle configure -contactName $contactName
    $handle configure -contactAddress1 $contactAddress1
    $handle configure -contactAddress2 $contactAddress2
    $handle configure -contactAddress3 $contactAddress3
    $handle configure -contactCity $contactCity
    $handle configure -contactState $contactState
    $handle configure -contactPostalCode $contactPostalCode
    $handle configure -contactCountry $contactCountry
    $handle configure -contactTelephone $contactTelephone
    $handle configure -contactEmail $contactEmail
    close $fp
    return
}


proc madInstrument_getEntries { handle mnemonic name latitude longitude \
                                altitude contactName contactAddress1 \
                                contactAddress2 contactAddress3 \
                                contactCity contactState contactPostalCode \
                                contactCountry contactTelephone \
                                contactEmail } {
    global debug
    if {$debug} {puts "Entering madInstrument_getEntries"}
    upvar 3 $mnemonic mnemonicL \
            $name nameL \
            $latitude latitudeL \
            $longitude longitudeL \
            $altitude altitudeL \
            $contactName contactNameL \
            $contactAddress1 contactAddress1L \
            $contactAddress2 contactAddress2L \
            $contactAddress3 contactAddress3L \
            $contactCity contactCityL \
            $contactState contactStateL \
            $contactPostalCode contactPostalCodeL \
            $contactCountry contactCountryL \
            $contactTelephone contactTelephoneL \
            $contactEmail contactEmailL
    array set mnemonicL [$handle cget -mnemonic]
    array set nameL [$handle cget -name]
    array set latitudeL [$handle cget -latitude]
    array set longitudeL [$handle cget -longitude]
    array set altitudeL [$handle cget -altitude]
    array set contactNameL [$handle cget -contactName]
    array set contactAddress1L [$handle cget -contactAddress1]
    array set contactAddress2L [$handle cget -contactAddress2]
    array set contactAddress3L [$handle cget -contactAddress3]
    array set contactCityL [$handle cget -contactCity]
    array set contactStateL [$handle cget -contactState]
    array set contactPostalCodeL [$handle cget -contactPostalCode]
    array set contactCountryL [$handle cget -contactCountry]
    array set contactTelephoneL [$handle cget -contactTelephone]
    array set contactEmailL [$handle cget -contactEmail]
    return
}


proc madInstrument_write { handle } {
    global debug
    if {$debug} {puts "Entering madInstrument_write"}
    return
}


proc madInstrument_print { handle args } {
    global debug
    if {$debug} {puts "Entering madInstrument_print"}
    $handle getEntries mnemonic name latitude longitude \
                       altitude contactName contactAddress1 \
                       contactAddress2 contactAddress3 \
                       contactCity contactState contactPostalCode \
                       contactCountry contactTelephone contactEmail
    foreach code [array names mnemonic] {
        if {[catch [set lat [format %8.2f $latitude($code)]]]} {
            set latitude($code) -32767
        }
        if [catch [set lat [format %8.2f $longitude($code)]]] {
            set longitude($code) -32767
        }
        if [catch [set lat [format %8.2f $altitude($code)]]] {
            set altitude($code) -32767
        }
        puts [format "%4.4d %3s %s %s %s %s %s %s %s %s %s %s %s %s %s %s" \
            $code $mnemonic($code) $name($code) $latitude($code) \
            $longitude($code) $altitude($code) $contactName($code) \
            $contactAddress1($code) $contactAddress2($code) \
            $contactAddress3($code) $contactCity($code) \
            $contactState($code) $contactPostalCode($code) \
            $contactCountry($code) $contactTelephone($code) \
            $contactEmail($code)]
    }
    return
}


proc madInstrument_init { handle } {
    global debug
    metadata_init $handle
    if {$debug} {puts "Entering madInstrument_init"}
    return
}


proc madInstrument_exit { handle } {
    return
}


#
# madSite
#

proc madSite_read { handle } {
    global debug
    if {$debug} {puts "Entering madSite_read"}
    set madroot [$handle cget -madroot]
    set fp [open [file join $madroot metadata siteTab.txt] r]
    set name {}
    set server {}
    set documentRoot {}
    set cgiDirectory {}
    while {[gets $fp line] >= 0} {
	set siteItem [split $line ,]
	set name [lappend name [lindex $siteItem 0]]
	set name [lappend name [lindex $siteItem 1]]
	set server [lappend server [lindex $siteItem 0]]
	set server [lappend server [lindex $siteItem 2]]
	set documentRoot [lappend documentRoot [lindex $siteItem 0]]
	set documentRoot [lappend documentRoot [lindex $siteItem 3]]
	set cgiDirectory [lappend cgiDirectory [lindex $siteItem 0]]
	set cgiDirectory [lappend cgiDirectory [lindex $siteItem 4]]
    }
    $handle configure -name $name
    $handle configure -server $server
    $handle configure -documentRoot $documentRoot
    $handle configure -cgiDirectory $cgiDirectory
    close $fp
    return
}


proc madSite_write { handle } {
    return
}


proc madSite_getEntries { handle name server documentRoot cgiDirectory} {
    global debug
    if {$debug} {puts "Entering madSite_getEntries"}
    upvar 3 $name nameL $server serverL $documentRoot documentRootL \
            $cgiDirectory cgiDirectoryL
    array set nameL [$handle cget -name]
    array set serverL [$handle cget -server]
    array set documentRootL [$handle cget -documentRoot]
    array set cgiDirectoryL [$handle cget -cgiDirectory]
    return
}


proc madSite_print { handle args } {
    global debug
    if {$debug} {puts "Entering madSite_print"}
    $handle getEntries siteName siteServer documentRoot cgiDirectory
    foreach id [array names siteServer] {
        puts [format "%4.4d %s %s %s %s" \
              $id $siteName($id) $siteServer($id) $documentRoot($id) $cgiDirectory($id)]
    }
    return
}

proc madSite_init { handle } {
    global debug
    metadata_init $handle
    if {$debug} {puts "Entering madSite_init"}
    return
}


proc madSite_exit { handle } {
    return
}


#
# madDataType
#

proc madDataType_read { handle } {
    global debug
    if {$debug} {puts "Entering madDataType_read"}
    set madroot [$handle cget -madroot]
    set fp [open [file join $madroot metadata typeTab.txt] r]
    set description {}
    while {[gets $fp line] >= 0} {
	set typeItem [split $line ,]
	set description [lappend description [lindex $typeItem 0]]
	set description [lappend description [lindex $typeItem 1]]
    }
    $handle configure -description $description
    close $fp
    return
}


proc madDataType_write { handle } {
    return
}


proc madDataType_getEntries { handle description } {
    global debug
    if {$debug} {puts "Entering madDataType_getEntries"}
    upvar 3 $description descriptionL
    array set descriptionL [$handle cget -description]
    return
}


proc madDataType_print { handle args } {
    global debug
    if {$debug} {puts "Entering madDataType_print"}
    $handle getEntries description
    foreach code [array names description] {
        puts [format "%4.4d %s" \
              $code $description($code)]
    }
    return
}


proc madDataType_init { handle } {
    global debug
    metadata_init $handle
    if {$debug} {puts "Entering madDataType_init"}
    return
}


proc madDataType_exit { handle } {
    return
}


#
# madExp
#

proc madExp_read { handle } {
}


proc madExp_write { handle } {
}


proc madExp_print { handle args } {
}


proc madExp_init { handle } {
    global debug
    metadata_init $handle
    if {$debug} {puts "Entering madExp_init"}
    return
}


proc madExp_exit { handle } {
}


#
# madFile
#

proc madFile_read { handle } {
    global debug
    if {$debug} {puts "Entering madFile_read"}
    set madroot [$handle cget -madroot]
    set metadataDir [$handle cget -metadataDir]
    set fp [open [file join $metadataDir fileTab.txt] r]
    set fileName {}
    set experimentID {}
    set dataType {}
    set category {}
    set spare1 {}
    set hasCatalog {}
    set hasHeader {}
    set analysisDate {}
    set analysisTime {}
    set spare4 {}
    set spare5 {}
    while {[gets $fp line] >= 0} {
	set typeItem [split $line ,]
	set experimentID [lappend experimentID [lindex $typeItem 0]]
	set experimentID [lappend experimentID [lindex $typeItem 1]]
	set dataType [lappend dataType [lindex $typeItem 0]]
	set dataType [lappend dataType [lindex $typeItem 2]]
	set category [lappend category [lindex $typeItem 0]]
	set category [lappend category [lindex $typeItem 3]]
	set spare1 [lappend spare1 [lindex $typeItem 0]]
	set spare1 [lappend spare1 [lindex $typeItem 4]]
	set hasCatalog [lappend hasCatalog [lindex $typeItem 0]]
	set hasCatalog [lappend hasCatalog [lindex $typeItem 5]]
	set hasHeader [lappend hasHeader [lindex $typeItem 0]]
	set hasHeader [lappend hasHeader [lindex $typeItem 6]]
	set analysisDate [lappend analysisDate [lindex $typeItem 0]]
	set analysisDate [lappend analysisDate [lindex $typeItem 7]]
	set analysisTime [lappend analysisTime [lindex $typeItem 0]]
	set analysisTime [lappend analysisTime [lindex $typeItem 8]]
	set spare4 [lappend spare4 [lindex $typeItem 0]]
	set spare4 [lappend spare4  [lindex $typeItem 9]]
	set spare5 [lappend spare5 [lindex $typeItem 0]]
	set spare5 [lappend spare5 [lindex $typeItem 10]]
    }
    close $fp
    $handle configure -files [list $experimentID \
                                   $dataType \
                                   $category \
                                   $spare1 \
                                   $hasCatalog \
                                   $hasHeader \
                                   $analysisDate \
                                   $analysisTime \
                                   $spare4 \
                                   $spare5]
    return
}


proc madFile_write { handle } {
    global debug
    if {$debug} {puts "Entering madFile_write"}
    set expPath [$handle cget -expPath]
    set tempTab [file join $expPath temp.txt]
    set fileTab [file join $expPath fileTab.txt]
    set fp [open $tempTab w]
    $handle getEntries experimentID dataType category spare1 hasCatalog \
                       hasHeader analysisDate analysisTime spare4 spare5
    foreach file [array names experimentID] {
        puts -nonewline $fp "$file,"
        puts -nonewline $fp "$experimentID($file),"
        puts -nonewline $fp "$dataType($file),"
        puts -nonewline $fp "$category($file),"
        puts -nonewline $fp "$spare1($file),"
        puts -nonewline $fp "$hasCatalog($file),"
        puts -nonewline $fp "$hasHeader($file),"
        puts -nonewline $fp "$analysisDate($file),"
        puts -nonewline $fp "$analysisTime($file),"
        puts -nonewline $fp "$spare4($file),"
        puts $fp $spare5($file)
    }
    close $fp
    exec sort $tempTab > $fileTab
    exec rm $tempTab
    return
}


proc madFile_getEntries { handle experimentID dataType category spare1 hasCatalog \
                          hasHeader analysisDate analysisTime spare4 spare5 } {
    global debug
    if {$debug} {puts "Entering madFile_getEntries"}
    upvar 3 $experimentID experimentIDL $dataType dataTypeL $category categoryL \
            $spare1 spare1L $hasCatalog hasCatalogL $hasHeader hasHeaderL \
            $analysisDate analysisDateL $analysisTime analysisTimeL \
            $spare4 spare4L $spare5 spare5L
    set files [$handle cget -files]
    array set experimentIDL [lindex $files 0]
    array set dataTypeL [lindex $files 1]
    array set categoryL [lindex $files 2]
    array set spare1L [lindex $files 3]
    array set hasCatalogL [lindex $files 4]
    array set hasHeaderL [lindex $files 5]
    array set analysisDateL [lindex $files 6]
    array set analysisTimeL [lindex $files 7]
    array set spare4L [lindex $files 8]
    array set spare5L [lindex $files 9]
    return
}


proc madFile_addFile { handle fileName experimentID dataType category spare1 hasCatalog \
                       hasHeader analysisDate analysisTime spare4 spare5 } {
    return
}


proc madFile_print { handle args } {
    global debug
    if {$debug} {puts "Entering madFile_print"}
    $handle getEntries experimentID dataType category spare1 hasCatalog \
                       hasHeader analysisDate analysisTime spare4 spare5
    foreach file [array names experimentID] {
        puts [format "%s %d %5d %1d %8d %8d %8d %8d %8d %1d %1d" \
              $file $experimentID($file) $dataType($file) $category($file) \
              $spare1($file) $hasCatalog($file) $hasHeader($file) $analysisDate($file) \
              $analysisTime($file) $spare4($file) $spare5($file)]
    }
    return
}


proc madFile_init { handle } {
    global debug
    metadata_init $handle
    if {$debug} {puts "Entering madFile_init"}
    return
}


proc madFile_exit { handle } {
    return
}


#
# madData
#

proc madData_read { handle } {
    global debug
    if {$debug} {puts "Entering madData_read"}
    set madroot [$handle cget -madroot]
    set metadataDir [$handle cget -metadataDir]
    set fp [open [file join $metadataDir dataTab.txt] r]
    set experimentID {}
    set dataType {}
    while {[gets $fp line] >= 0} {
	set typeItem [split $line ,]
	set experimentID [lappend experimentID [lindex $typeItem 0]]
	set experimentID [lappend experimentID [lindex $typeItem 1]]
	set dataType [lappend dataType [lindex $typeItem 0]]
	set dataType [lappend dataType [lindex $typeItem 2]]
    }
    close $fp
    $handle configure -data [list $experimentID \
                                  $dataType]
    return
}


proc madData_write { handle } {
    global debug
    if {$debug} {puts "Entering madData_write"}
    set expPath [$handle cget -expPath]
    set tempTab [file join $expPath temp.txt]
    set dataTab [file join $expPath dataTab.txt]
    set fp [open $tempTab w]
    $handle getEntries experimentID dataType
    foreach day [array names experimentID] {
        puts -nonewline $fp "$day,"
        puts -nonewline $fp "$experimentID($day),"
        puts $fp $dataType($day)
    }
    close $fp
    exec sort $tempTab > $dataTab
    exec rm $tempTab

    return
}


proc madData_getEntries { handle experimentID dataType } {
    global debug
    if {$debug} {puts "Entering madData_getEntries"}
    upvar 3 $experimentID experimentIDL $dataType dataTypeL
    set data [$handle cget -data]
    array set experimentIDL [lindex $data 0]
    array set dataTypeL [lindex $data 1]
    return
}


proc madData_addFile { handle day experimentID dataType } {
}


proc madData_print { handle args } {
    global debug
    if {$debug} {puts "Entering madData_print"}
    $handle getEntries experimentID dataType
    foreach day [array names experimentID] {
        puts [format "%s %d" \
              $day $experimentID($day) $dataType($day)]
    }
    return
}


proc madData_init { handle } {
     global debug
    metadata_init $handle
    if {$debug} {puts "Entering madData_init"}
    return
}


proc madData_exit { handle } {
}


#
# madInventory
#

proc madInventory_read { handle } {
    global debug
    if {$debug} {puts "Entering madInventory_read"}
    set madroot [$handle cget -madroot]
    set metadataDir [$handle cget -metadataDir]
    set inventoryFile [$handle cget -fileName]
    set fp [open [file join $metadataDir $inventoryFile] r]
    set experimentURL {}
    set databaseSiteID {}
    set experimentStartDate {}
    set experimentStartTime {}
    set experimentEndDate {}
    set experimentEndTime {}
    set instrumentCode {}
    set instrumentMnemonic {}
    set instrumentName {}
    set experimentName {}

    # Read the inventory table
    while {[gets $fp line] >= 0} {
        set inventoryItem [split $line ,]
        set experimentURL [lappend experimentURL [lindex $inventoryItem 0]]
        set experimentURL [lappend experimentURL [lindex $inventoryItem 1]]
        set databaseSiteID [lappend databaseSiteID [lindex $inventoryItem 0]]
        set databaseSiteID [lappend databaseSiteID [lindex $inventoryItem 2]]
        set experimentStartDate [lappend experimentStartDate [lindex $inventoryItem 0]]
        set experimentStartDate [lappend experimentStartDate [lindex $inventoryItem 3]]
        set experimentStartTime [lappend experimentStartTime [lindex $inventoryItem 0]]
        set experimentStartTime [lappend experimentStartTime [lindex $inventoryItem 4]]
        set experimentEndDate [lappend experimentEndDate [lindex $inventoryItem 0]]
        set experimentEndDate [lappend experimentEndDate [lindex $inventoryItem 5]]
        set experimentEndTime [lappend experimentEndTime [lindex $inventoryItem 0]]
        set experimentEndTime [lappend experimentEndTime [lindex $inventoryItem 6]]
        set instrumentCode [lappend instrumentCode [lindex $inventoryItem 0]]
        set instrumentCode [lappend instrumentCode [lindex $inventoryItem 7]]
        set instrumentMnemonic [lappend instrumentMnemonic [lindex $inventoryItem 0]]
        set instrumentMnemonic [lappend instrumentMnemonic [lindex $inventoryItem 8]]
        set instrumentName [lappend instrumentName [lindex $inventoryItem 0]]
        set instrumentName [lappend instrumentName [lindex $inventoryItem 9]]
        set experimentName [lappend experimentName [lindex $inventoryItem 0]]
        set experimentName [lappend experimentName [lindex $inventoryItem 10]]
    }
    $handle configure -experimentURL $experimentURL
    $handle configure -databaseSiteID $databaseSiteID
    $handle configure -experimentStartDate $experimentStartDate
    $handle configure -experimentStartTime $experimentStartTime
    $handle configure -experimentEndDate $experimentEndDate
    $handle configure -experimentEndTime $experimentEndTime
    $handle configure -instrumentCode $instrumentCode
    $handle configure -instrumentMnemonic $instrumentMnemonic
    $handle configure -instrumentName $instrumentName
    $handle configure -experimentName $experimentName
    close $fp

    return
}


proc madInventory_write { handle } {
}


proc madInventory_getEntries { handle experimentURL databaseSiteID \
                               experimentStartDate  experimentStartTime \
                               experimentEndDate experimentEndTime \
                               instrumentCode instrumentMnemonic \
                               instrumentName experimentName} {
    global debug
    if {$debug} {puts "Entering madInventory_getEntries"}
    upvar 3 $experimentURL experimentURLL \
            $databaseSiteID databaseSiteIDL \
            $experimentStartDate experimentStartDateL \
            $experimentStartTime experimentStartTimeL \
            $experimentEndDate experimentEndDateL \
            $experimentEndTime experimentEndTimeL \
            $instrumentCode instrumentCodeL \
            $instrumentMnemonic instrumentMnemonicL \
            $instrumentName instrumentNameL \
            $experimentName experimentNameL        
    array set experimentURLL [$handle cget -experimentURL]
    array set databaseSiteIDL [$handle cget -databaseSiteID]
    array set experimentStartDateL [$handle cget -experimentStartDate]
    array set experimentStartTimeL [$handle cget -experimentStartTime]
    array set experimentEndDateL [$handle cget -experimentEndDate]
    array set experimentEndTimeL [$handle cget -experimentEndTime]
    array set instrumentCodeL [$handle cget -instrumentCode]
    array set instrumentMnemonicL [$handle cget -instrumentMnemonic]
    array set instrumentNameL [$handle cget -instrumentName]
    array set experimentNameL [$handle cget -experimentName]
    return
}


proc madInventory_print { handle args } {
    global debug
    if {$debug} {puts "Entering madInventory_print"}
    $handle getEntries experimentURL databaseSiteID experimentStartDate \
                       experimentStartTime experimentEndDate experimentEndTime \
                       instrumentCode instrumentMnemonic instrumentName \
                       experimentName
    foreach id [ array names experimentURL ] {
    puts "$id $experimentURL($id) $databaseSiteID($id) \
              $experimentStartDate($id) $experimentStartTime($id) \
              $experimentEndDate($id) $experimentEndTime($id) \
              $instrumentCode($id) $instrumentMnemonic($id) \
              $instrumentName($id) $experimentName($id)"
    }
    return
}


proc madInventory_init { handle } {
    global debug
    metadata_init $handle
    if {$debug} {puts "Entering madInventory_init"}
    return
}


proc madInventory_exit { handle } {
    return
}


proc calcJulianDay {year month day} {
    # Small standalone routine to calculate Julian day given input day,
    # month, and year. The algorithm is from "Practical Astronomy With
    # Your Calculator", Peter Duffett-Smith, 2nd Edition, Cambridge Univ.
    # Press, London.

    set y $year
    set m [string trimleft $month "0"]
    set d [string trimleft $day "0"]
    if {$month <= 2} {
        set y [expr $y - 1]
        set m [expr $m + 12]
    }
    set A [expr int($y/100)]
    set B [expr 2 - $A + int($A/4)]
    set C [expr int(365.25*$y)]
    set D [expr int(30.6001*($m + 1))]
    set jday [expr int(($B + $C + $D + $d) + 1720994.5)]
    return $jday
}

proc translateCedarFile { infile outfile fileType } {
    # Copies infile to outfile. Infile may be any valid Cedar file type.
    # THe type is detected automatically. Outfile will be Madrigal format.

    # Create madrec object for the input file. Specify file type 1 for
    # automatic determination of the CEDAR file type
    mad madin
    if {[file exists $infile]} {
        catch [$madin open 1 $infile]
    } else {
        puts "Input file $infile does not exist"
        exit
    }

    # Create madrec object for the output file. Specify madrigal format
    mad madout
    $madout open $fileType $outfile

    while {[$madin getNextRecord] == 0} {
        $madin copy $madout
        $madout putNextRecord
    }

    # Close input file and destroy madrec objects
    $madin close
    $madin destroy
    $madout close
    $madout destroy
    return
}
